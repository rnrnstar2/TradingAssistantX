# ワークフロー仕様書

## 概要

TradingAssistantXのメインワークフローは、Kaito API、Claude SDK、データ管理システムを統合した実行フローです。dev実行とmain実行はほぼ同じコードを使用し、違いはスケジュール実行か手動実行かのみです。両方のモードでYAMLファイルからデータを取得しますが、取得タイミングが異なります。

> **📂 実装構造**: 詳細なディレクトリ構造は [directory-structure.md](directory-structure.md) を参照
> **🤖 Claude SDK仕様**: [claude.md](claude.md) を参照
> **🔐 Kaito API仕様**: [kaito-api.md](kaito-api.md) を参照

## メインワークフロー

### 実行フロー概要

#### dev実行時（3ステップ）
```
1. データ収集 → 2. アクション実行（YAML指定） → 3. 結果保存
```
**注意**: YAMLの中の1つを固定インプットとして使用し、Claude判断ステップは不要です。

#### スケジュール実行時（4ステップ）
```
1. スケジュール判定（1分ごと） → 2. データ収集 → 3. アクション実行（時刻ベースYAML） → 4. 結果保存
```
**注意**: 1分ごとに時刻をチェックし、対応する時刻になったらYAMLから特定のデータを取得して実行します。Claude判断ステップは不要です。

### Step 1: スケジュール判定（スケジュール実行時のみ）
**目的**: 1分ごとに時刻をチェックし、実行タイミングを判定

**実行内容**:
- 現在時刻を"HH:MM"形式で取得
- schedule.yamlから対応するタスクを検索
- 実行対象があればStep 2以降を実行
- なければ1分待機して繰り返し

**注意**: dev実行時はこのステップはスキップされ、直接Step 2から開始します。

### Step 2: データ収集
**目的**: 現在のコンテキストを取得し、判断材料を準備

**収集データ**:
- Twitterアカウント状態（フォロワー数、投稿履歴）
- 過去の学習データ（decision-patterns.yaml）
- 現在時刻と前回実行からの経過時間

### Step 3: アクション実行
**目的**: YAMLから取得したアクションを実行（Claude判断不要）

#### dev実行時
- YAMLの中の1つを固定で使用
- 事前決定されたアクションを直接実行

#### スケジュール実行時
- 時刻に対応するYAML inputを取得
- 時刻別に事前決定されたアクションを直接実行

**実行可能アクション**:
- `post`: 新規投稿（教育コンテンツ）
- `retweet`: 関連ツイートのリツイート
- `quote_tweet`: 引用リツイート
- `like`: いいね
- `wait`: 待機（何もしない）

**実行詳細**:
- **post**: Claude SDKでコンテンツ生成 → 投稿
- **retweet**: 指定IDまたは検索結果からリツイート
- **quote_tweet**: 引用コメント生成 → 引用RT
- **like**: 指定ツイートにいいね
- **wait**: ログ出力のみ

### Step 4: 結果保存
**目的**: 実行結果を履歴として保存

**保存内容**:
- タイムスタンプ
- アクション入力内容
- 実行結果
- パフォーマンス分析

**保存先**: `data/history/YYYY-MM/DD-HHMM/`
- `actionInput.yaml`: アクション入力内容
- `result.yaml`: 実行結果
- `analysis.yaml`: パフォーマンス分析

## スケジュール実行システム

### 時刻ベース実行
YAMLファイルで定義された時刻に自動的にワークフローを実行します。

### スケジュール設定（schedule.yaml）

**設定例**:
- 朝07:00: 投稿（朝の投資教育）
- 朝08:00: リツイート（初心者向けコンテンツ）
- 昼12:00: 投稿（市場動向解説）
- 昼12:30: いいね（高品質教育コンテンツ）
- 夜18:00: 引用RT（ニュース解説）
- 夜21:00: 投稿（明日の注目ポイント）

### 設定項目説明

#### スケジュール構造
- **フラット形式**: 時間帯区分なし、時刻リストによる設定
- **アクション決定不要**: スケジュール実行時はアクションが事前決定されているため、Claude判断ステップをスキップ

#### アクション別パラメータ
| アクション | 必須パラメータ | 用途 |
|-----------|---------------|------|
| post | topic | 投稿トピック指定 |
| retweet | target_query | 検索クエリ |
| quote_tweet | target_query, topic | 検索クエリと引用コメントトピック |
| like | target_query | 検索クエリ |

### スケジューラー動作仕様

**動作概要**:
- 1分間隔で時刻チェック
- 現在時刻で実行タスクを検索
- 対象があればMainWorkflowを実行
- なければ1分待機して繰り返し

**特徴**:
- 1分精度での時刻チェック
- 実行時刻になると即座にワークフロー起動
- エラー時も継続動作（個別タスクの失敗でスケジューラーは停止しない）

## エントリーポイント

### 開発用: pnpm dev
**ファイル**: `src/dev.ts`
**用途**: 単一実行、即座にワークフローを1回実行して終了
**特徴**: 
- 環境変数を`.env`ファイルから自動読み込み（dotenv.config()）
- MainWorkflowクラスを使用（mainとほぼ同じコード）
- YAMLの中の1つを適当なインプットとして使用（Claude判断不要）

`pnpm dev` → 環境変数読み込み → ワークフロー実行 → 終了

### 本番用: pnpm start
**ファイル**: `src/main.ts`  
**用途**: スケジュール実行、YAMLファイルに従って継続実行
**特徴**:
- 環境変数を`.env`ファイルから自動読み込み（dotenv.config()）
- TimeSchedulerによる時刻ベース実行
- YAMLから特定の時刻のデータを取得してインプット
- devとほぼ同じコード（違いはスケジュール実行か手動実行か）

`pnpm start` → 環境変数読み込み → スケジューラー開始 → 継続実行（Ctrl+Cで終了）

## 実行フロー図

### dev実行（pnpm dev）
```
┌─────────┐     ┌──────────────┐     ┌─────────────┐
│ dev.ts  │ --> │ MainWorkflow │ --> │ 3ステップ   │ --> 終了
└─────────┘     │   .execute() │     │ 実行        │
                └──────────────┘     └─────────────┘
                                     │固定YAML入力 │
                                     │Claude判断なし│
```

### スケジュール実行（pnpm start）
```
┌─────────┐     ┌───────────────┐     ┌──────────────┐
│ main.ts │ --> │TimeScheduler  │ --> │schedule.yaml │
└─────────┘     │   .start()    │     │ 読み込み     │
                └───────┬───────┘     └──────────────┘
                        │ 
                        ↓ 1分ごとにチェック
                ┌───────────────┐     ┌─────────────┐
                │ 時刻到達？    │ Yes │MainWorkflow │
                │               │ --> │  .execute() │
                └───────────────┘     └─────────────┘
                        ↓ No         │ 3ステップ   │
                    次の1分待機        │時刻別YAML入力│
                                     │Claude判断なし│
```

**共通点**: 両方とも同じMainWorkflowクラスを3ステップ（データ収集→アクション実行→結果保存）で実行し、YAMLからデータを取得します。Claude判断ステップは両モードで不要になり、事前決定されたアクションを直接実行します。違いは取得タイミングとスケジュール判定の有無のみです。

## エラーハンドリング

### ワークフロー実行エラー
- 個別のワークフロー実行エラーはログ出力
- スケジューラーは継続動作
- 次の実行時刻を待機

### スケジューラーエラー
- YAMLファイル読み込みエラー → 起動失敗
- 致命的エラー → プロセス終了（exit code 1）

## 設定ファイル

### 必要な設定ファイル
- `data/config/schedule.yaml`: スケジュール設定（必須）
- `data/config/api-config.yaml`: API設定
- `data/config/system-config.yaml`: システム設定

### 環境変数

**必要な環境変数**:
- `X_USERNAME`: X（Twitter）ユーザー名
- `X_PASSWORD`: X（Twitter）パスワード
- `X_EMAIL`: X（Twitter）メールアドレス
- `X_TOTP_SECRET`: 2FA用のTOTPシークレット

**プロキシ設定**:
- プロキシは`data/config/proxies.yaml`で管理
- 複数プロキシの自動ローテーション対応

**注意**: 
- 旧環境変数名（TWITTER_USERNAME等）は廃止
- X_で始まる新しい環境変数名を使用
- `.env`ファイルは自動的に読み込まれます

## 実装詳細

### KaitoApiClient初期化

**初期化手順**:
1. KaitoAPIConfigManagerで設定生成
2. KaitoApiClientインスタンス作成
3. 設定で初期化
4. httpClientが正しく設定され、API通信が可能に

## パフォーマンス考慮事項

### API制限対応
- Kaito API: 15分あたり15リクエスト制限
- 適切な間隔での実行スケジュール設定が重要

### メモリ効率
- 単一ループでの時刻チェック
- 大量のタイマー生成を回避
- 実行結果の適切な保存とクリーンアップ
