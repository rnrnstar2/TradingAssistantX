{"version":3,"sources":["../src/_internal/transport/subprocess-cli.ts","../src/types/base-error.ts","../src/types/enhanced-errors.ts","../src/errors.ts","../src/_internal/transport/subprocess-abort-handler.ts","../src/environment.ts","../src/_internal/options-merger.ts","../src/_internal/client.ts","../src/types/telemetry.ts","../src/types/retry.ts","../src/types/environment.ts","../src/parser.ts","../src/permissions/manager.ts","../src/config/loader.ts","../src/roles/manager.ts","../src/logger.ts","../src/fluent.ts","../src/streaming/token-stream.ts","../src/permissions/tool-permissions.ts","../src/telemetry/provider-simple.ts","../src/retry/executor.ts","../src/index.ts"],"sourcesContent":["import { execa, type ExecaChildProcess } from 'execa';\nimport which from 'which';\nimport { createInterface } from 'node:readline';\nimport { platform } from 'node:os';\nimport { join } from 'node:path';\nimport { homedir } from 'node:os';\nimport { access, constants } from 'node:fs/promises';\nimport { CLIConnectionError, CLINotFoundError, ProcessError, CLIJSONDecodeError, AbortError } from '../../errors.js';\nimport type { ClaudeCodeOptions, CLIOutput } from '../../types.js';\nimport { SubprocessAbortHandler } from './subprocess-abort-handler.js';\n\nexport class SubprocessCLITransport {\n  private process?: ExecaChildProcess;\n  private options: ClaudeCodeOptions;\n  private prompt: string;\n  private abortHandler?: SubprocessAbortHandler;\n  private cleanupAbort?: () => void;\n\n  constructor(prompt: string, options: ClaudeCodeOptions = {}) {\n    this.prompt = prompt;\n    this.options = options;\n  }\n\n  private async findCLI(): Promise<string> {\n    // First check for local Claude installation (newer version with --output-format support)\n    const localPaths = [\n      join(homedir(), '.claude', 'local', 'claude'),\n      join(homedir(), '.claude', 'bin', 'claude')\n    ];\n    \n    for (const path of localPaths) {\n      try {\n        await access(path, constants.X_OK);\n        return path;\n      } catch {\n        // Continue checking\n      }\n    }\n    \n    // Then try to find in PATH - try both 'claude' and 'claude-code' for compatibility\n    try {\n      return await which('claude');\n    } catch {\n      // Try the alternative name\n      try {\n        return await which('claude-code');\n      } catch {\n        // Not found in PATH, continue to check other locations\n      }\n    }\n\n    // Common installation paths to check\n    const paths: string[] = [];\n    const isWindows = platform() === 'win32';\n    const home = homedir();\n\n    if (isWindows) {\n      paths.push(\n        join(home, 'AppData', 'Local', 'Programs', 'claude', 'claude.exe'),\n        join(home, 'AppData', 'Local', 'Programs', 'claude-code', 'claude-code.exe'),\n        'C:\\\\Program Files\\\\claude\\\\claude.exe',\n        'C:\\\\Program Files\\\\claude-code\\\\claude-code.exe'\n      );\n    } else {\n      paths.push(\n        '/usr/local/bin/claude',\n        '/usr/local/bin/claude-code',\n        '/usr/bin/claude',\n        '/usr/bin/claude-code',\n        '/opt/homebrew/bin/claude',\n        '/opt/homebrew/bin/claude-code',\n        join(home, '.local', 'bin', 'claude'),\n        join(home, '.local', 'bin', 'claude-code'),\n        join(home, 'bin', 'claude'),\n        join(home, 'bin', 'claude-code'),\n        join(home, '.claude', 'local', 'claude')  // Claude's custom installation path\n      );\n    }\n\n    // Try global npm/yarn paths\n    try {\n      const { stdout: npmPrefix } = await execa('npm', ['config', 'get', 'prefix']);\n      if (npmPrefix) {\n        paths.push(\n          join(npmPrefix.trim(), 'bin', 'claude'),\n          join(npmPrefix.trim(), 'bin', 'claude-code')\n        );\n      }\n    } catch {\n      // Ignore error and continue\n    }\n\n    // Check each path\n    for (const path of paths) {\n      try {\n        await execa(path, ['--version']);\n        return path;\n      } catch {\n      // Ignore error and continue\n    }\n    }\n\n    throw new CLINotFoundError();\n  }\n\n  private buildCommand(): string[] {\n    // Build command following Python SDK pattern\n    const args: string[] = ['--output-format', 'stream-json', '--verbose'];\n\n    // Claude CLI supported flags (from --help)\n    if (this.options.model) args.push('--model', this.options.model);\n    // Don't pass --debug flag as it produces non-JSON output\n    \n    // Note: Claude CLI handles authentication internally\n    // Authentication is managed entirely by the CLI\n\n    // Handle session resumption\n    if (this.options.sessionId) {\n      args.push('--resume', this.options.sessionId);\n    }\n\n    // Handle allowed/disallowed tools (Claude CLI uses camelCase flags)\n    if (this.options.allowedTools && this.options.allowedTools.length > 0) {\n      args.push('--allowedTools', this.options.allowedTools.join(','));\n    }\n    if (this.options.deniedTools && this.options.deniedTools.length > 0) {\n      args.push('--disallowedTools', this.options.deniedTools.join(','));\n    }\n\n    // Handle permission mode - map to CLI's actual flag\n    if (this.options.permissionMode === 'bypassPermissions') {\n      args.push('--dangerously-skip-permissions');\n    }\n    // Note: 'default' and 'acceptEdits' are not supported by current CLI version\n\n    // Handle MCP config\n    if (this.options.mcpServers && this.options.mcpServers.length > 0) {\n      const mcpConfig = {\n        mcpServers: this.options.mcpServers\n      };\n      args.push('--mcp-config', JSON.stringify(mcpConfig));\n    }\n\n    // Handle MCP server permissions\n    if (this.options.mcpServerPermissions && Object.keys(this.options.mcpServerPermissions).length > 0) {\n      args.push('--mcp-server-permissions', JSON.stringify(this.options.mcpServerPermissions));\n    }\n\n    // Handle configuration file\n    if (this.options.configFile) {\n      args.push('--config-file', this.options.configFile);\n    }\n\n    // Handle role\n    if (this.options.role) {\n      args.push('--role', this.options.role);\n    }\n\n    // Handle additional context\n    if (this.options.context && this.options.context.length > 0) {\n      args.push('--context', ...this.options.context);\n    }\n\n    // Handle temperature\n    if (this.options.temperature !== undefined) {\n      args.push('--temperature', this.options.temperature.toString());\n    }\n\n    // Handle max tokens\n    if (this.options.maxTokens !== undefined) {\n      args.push('--max-tokens', this.options.maxTokens.toString());\n    }\n\n    // Handle add directories\n    if (this.options.addDirectories && this.options.addDirectories.length > 0) {\n      args.push('--add-dir', this.options.addDirectories.join(' '));\n    }\n\n    // Add --print flag (prompt will be sent via stdin)\n    args.push('--print');\n\n    return args;\n  }\n\n  async connect(): Promise<void> {\n    const cliPath = await this.findCLI();\n    const args = this.buildCommand();\n\n    const env = {\n      ...process.env,\n      ...this.options.env,\n      CLAUDE_CODE_ENTRYPOINT: 'sdk-ts'\n    };\n\n    // Debug: Log the actual command being run\n    if (this.options.debug) {\n      // eslint-disable-next-line no-console\n      console.error('DEBUG: Running command:', cliPath, args.join(' '));\n    }\n\n    try {\n      // Don't pass signal to execa - we'll handle it manually\n      this.process = execa(cliPath, args, {\n        env,\n        cwd: this.options.cwd,\n        stdin: 'pipe',\n        stdout: 'pipe',\n        stderr: 'pipe',\n        buffer: false\n        // Remove signal from here - we'll handle it manually\n      });\n\n      // Set up abort handling with proper cleanup\n      this.abortHandler = new SubprocessAbortHandler(this.process, this.options.signal);\n      this.cleanupAbort = this.abortHandler.setup();\n      \n      // Send prompt via stdin\n      if (this.process.stdin) {\n        this.process.stdin.write(this.prompt);\n        this.process.stdin.end();\n      }\n    } catch (error) {\n      throw new CLIConnectionError(`Failed to start Claude Code CLI: ${error}`);\n    }\n  }\n\n  async *receiveMessages(): AsyncGenerator<CLIOutput> {\n    if (!this.process || !this.process.stdout) {\n      throw new CLIConnectionError('Not connected to CLI');\n    }\n\n    try {\n      // Handle stderr in background\n      if (this.process.stderr) {\n        const stderrRl = createInterface({\n          input: this.process.stderr,\n          crlfDelay: Infinity\n        });\n        \n        stderrRl.on('line', (line) => {\n          if (this.options.debug) {\n            // eslint-disable-next-line no-console\n            console.error('DEBUG stderr:', line);\n          }\n        });\n      }\n\n      const rl = createInterface({\n        input: this.process.stdout,\n        crlfDelay: Infinity\n      });\n\n      // Process stream-json format - each line is a JSON object\n      for await (const line of rl) {\n        const trimmedLine = line.trim();\n        if (!trimmedLine) continue;\n        \n        if (this.options.debug) {\n          // eslint-disable-next-line no-console\n          console.error('DEBUG stdout:', trimmedLine);\n        }\n        \n        try {\n          const parsed = JSON.parse(trimmedLine) as CLIOutput;\n          yield parsed;\n        } catch (error) {\n          // Skip non-JSON lines (like Python SDK does)\n          if (trimmedLine.startsWith('{') || trimmedLine.startsWith('[')) {\n            throw new CLIJSONDecodeError(\n              `Failed to parse CLI output: ${error}`,\n              trimmedLine\n            );\n          }\n          continue;\n        }\n      }\n\n      // Wait for process to exit\n      try {\n        await this.process;\n      } catch (error: any) {\n        // Check if the process was cancelled/aborted\n        if (error.isCanceled || error.name === 'CancelError' || this.abortHandler?.wasAborted()) {\n          // Throw a proper AbortError so it can be caught by the user\n          throw new AbortError('Query was aborted via AbortSignal');\n        }\n        \n        const execError = error as { exitCode?: number; signal?: NodeJS.Signals };\n        if (execError.exitCode !== 0) {\n          throw new ProcessError(\n            `Claude Code CLI exited with code ${execError.exitCode}`,\n            execError.exitCode,\n            execError.signal\n          );\n        }\n      }\n    } finally {\n      // Clean up abort handler\n      if (this.cleanupAbort) {\n        this.cleanupAbort();\n      }\n    }\n  }\n\n  async disconnect(): Promise<void> {\n    // Clean up abort handler first\n    if (this.cleanupAbort) {\n      this.cleanupAbort();\n      this.cleanupAbort = undefined;\n    }\n    \n    if (this.process) {\n      // Kill the process if it's still running\n      if (!this.process.killed) {\n        this.process.kill();\n      }\n      this.process = undefined;\n    }\n    \n    this.abortHandler = undefined;\n  }\n}","/**\n * Base error class to avoid circular dependencies\n */\n\nexport class BaseSDKError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'BaseSDKError';\n    Object.setPrototypeOf(this, BaseSDKError.prototype);\n  }\n}","/**\n * Enhanced error types for better error handling\n */\n\nimport { BaseSDKError } from './base-error.js';\n\n// API Errors\n\nexport class APIError extends BaseSDKError {\n  constructor(\n    message: string,\n    public readonly statusCode?: number,\n    public readonly headers?: Record<string, string>\n  ) {\n    super(message);\n    this.name = 'APIError';\n    Object.setPrototypeOf(this, APIError.prototype);\n  }\n}\n\nexport class RateLimitError extends APIError {\n  constructor(\n    message: string,\n    public readonly retryAfter: number,\n    public readonly limit?: number,\n    public readonly remaining?: number,\n    public readonly resetAt?: Date\n  ) {\n    super(message, 429);\n    this.name = 'RateLimitError';\n    Object.setPrototypeOf(this, RateLimitError.prototype);\n  }\n}\n\nexport class AuthenticationError extends APIError {\n  constructor(\n    message: string,\n    public readonly authMethod?: 'oauth' | 'cli',\n    public readonly requiredAction?: string\n  ) {\n    super(message, 401);\n    this.name = 'AuthenticationError';\n    Object.setPrototypeOf(this, AuthenticationError.prototype);\n  }\n}\n\nexport class ModelNotAvailableError extends APIError {\n  constructor(\n    public readonly model: string,\n    public readonly availableModels?: string[],\n    public readonly reason?: 'not_found' | 'access_denied' | 'deprecated'\n  ) {\n    super(`Model not available: ${model}`, 404);\n    this.name = 'ModelNotAvailableError';\n    Object.setPrototypeOf(this, ModelNotAvailableError.prototype);\n  }\n}\n\nexport class ContextLengthExceededError extends APIError {\n  constructor(\n    public readonly currentTokens: number,\n    public readonly maxTokens: number,\n    public readonly truncationStrategy?: 'beginning' | 'middle' | 'end'\n  ) {\n    super(`Context length exceeded: ${currentTokens} > ${maxTokens} tokens`, 413);\n    this.name = 'ContextLengthExceededError';\n    Object.setPrototypeOf(this, ContextLengthExceededError.prototype);\n  }\n}\n\n// Permission Errors\n\nexport class PermissionError extends BaseSDKError {\n  constructor(\n    message: string,\n    public readonly resource?: string,\n    public readonly action?: string\n  ) {\n    super(message);\n    this.name = 'PermissionError';\n    Object.setPrototypeOf(this, PermissionError.prototype);\n  }\n}\n\nexport class ToolPermissionError extends PermissionError {\n  constructor(\n    public readonly tool: string,\n    public readonly permission: 'allow' | 'deny' | 'ask',\n    public readonly reason?: string,\n    public readonly context?: {\n      serverName?: string;\n      roleApplied?: string;\n      configSource?: 'global' | 'role' | 'query';\n    }\n  ) {\n    super(`Tool permission denied: ${tool}`, tool, 'execute');\n    this.name = 'ToolPermissionError';\n    Object.setPrototypeOf(this, ToolPermissionError.prototype);\n  }\n}\n\nexport class MCPServerPermissionError extends PermissionError {\n  constructor(\n    public readonly serverName: string,\n    public readonly permission: 'whitelist' | 'blacklist' | 'ask',\n    public readonly requestedTools?: string[]\n  ) {\n    super(`MCP server permission denied: ${serverName}`, serverName, 'connect');\n    this.name = 'MCPServerPermissionError';\n    Object.setPrototypeOf(this, MCPServerPermissionError.prototype);\n  }\n}\n\n// Network Errors\n\nexport class NetworkError extends BaseSDKError {\n  constructor(\n    message: string,\n    public readonly code?: string,\n    public readonly syscall?: string\n  ) {\n    super(message);\n    this.name = 'NetworkError';\n    Object.setPrototypeOf(this, NetworkError.prototype);\n  }\n}\n\nexport class ConnectionTimeoutError extends NetworkError {\n  constructor(\n    public readonly timeout: number,\n    public readonly operation?: string\n  ) {\n    super(`Connection timeout after ${timeout}ms`, 'ETIMEDOUT');\n    this.name = 'ConnectionTimeoutError';\n    Object.setPrototypeOf(this, ConnectionTimeoutError.prototype);\n  }\n}\n\nexport class ConnectionRefusedError extends NetworkError {\n  constructor(\n    public readonly host?: string,\n    public readonly port?: number\n  ) {\n    super(`Connection refused${host ? ` to ${host}:${port}` : ''}`, 'ECONNREFUSED');\n    this.name = 'ConnectionRefusedError';\n    Object.setPrototypeOf(this, ConnectionRefusedError.prototype);\n  }\n}\n\n// Streaming Errors\n\nexport class StreamingError extends BaseSDKError {\n  constructor(\n    message: string,\n    public readonly partialData?: unknown,\n    public readonly bytesReceived?: number\n  ) {\n    super(message);\n    this.name = 'StreamingError';\n    Object.setPrototypeOf(this, StreamingError.prototype);\n  }\n}\n\nexport class StreamAbortedError extends StreamingError {\n  constructor(\n    public readonly reason?: string,\n    public readonly abortedAt?: number,\n    partialData?: unknown\n  ) {\n    super(`Stream aborted${reason ? `: ${reason}` : ''}`, partialData);\n    this.name = 'StreamAbortedError';\n    Object.setPrototypeOf(this, StreamAbortedError.prototype);\n  }\n}\n\nexport class StreamPausedError extends StreamingError {\n  constructor(\n    public readonly pausedAt: number,\n    public readonly canResume: boolean = true\n  ) {\n    super('Stream is paused');\n    this.name = 'StreamPausedError';\n    Object.setPrototypeOf(this, StreamPausedError.prototype);\n  }\n}\n\n// Retry Errors\n\nexport class MaxRetriesExceededError extends BaseSDKError {\n  constructor(\n    public readonly lastError: Error,\n    public readonly attempts: number,\n    public readonly totalDelay?: number\n  ) {\n    super(`Max retries exceeded after ${attempts} attempts: ${lastError.message}`);\n    this.name = 'MaxRetriesExceededError';\n    Object.setPrototypeOf(this, MaxRetriesExceededError.prototype);\n  }\n}\n\nexport class CircuitOpenError extends BaseSDKError {\n  constructor(\n    public readonly openedAt: Date,\n    public readonly failureCount: number,\n    public readonly nextRetryAt?: Date\n  ) {\n    super('Circuit breaker is open');\n    this.name = 'CircuitOpenError';\n    Object.setPrototypeOf(this, CircuitOpenError.prototype);\n  }\n}\n\n// Type guards\n\nexport function isRateLimitError(error: unknown): error is RateLimitError {\n  return error instanceof RateLimitError;\n}\n\nexport function isAuthenticationError(error: unknown): error is AuthenticationError {\n  return error instanceof AuthenticationError;\n}\n\nexport function isToolPermissionError(error: unknown): error is ToolPermissionError {\n  return error instanceof ToolPermissionError;\n}\n\nexport function isStreamAbortedError(error: unknown): error is StreamAbortedError {\n  return error instanceof StreamAbortedError;\n}\n\nexport function isNetworkError(error: unknown): error is NetworkError {\n  return error instanceof NetworkError;\n}\n\nexport function isTimeoutError(error: unknown): error is TimeoutError {\n  return error instanceof TimeoutError;\n}\n\nexport function isValidationError(error: unknown): error is ValidationError {\n  return error instanceof ValidationError;\n}\n\nexport function isAPIError(error: unknown): error is APIError {\n  return error instanceof APIError;\n}\n\nexport function isRetryableError(error: unknown): boolean {\n  return (\n    error instanceof RateLimitError ||\n    error instanceof NetworkError ||\n    error instanceof ConnectionTimeoutError ||\n    (error instanceof APIError && \n     error.statusCode !== undefined && \n     error.statusCode >= 500)\n  );\n}\n\n// Error detection from CLI output\n\nexport interface ErrorDetectionPattern {\n  pattern: RegExp;\n  errorFactory: (match: RegExpMatchArray, output: string) => Error;\n}\n\n// Error types for detection\nexport type ErrorType = \n  | 'api_error'\n  | 'rate_limit_error'\n  | 'authentication_error'\n  | 'model_not_available_error'\n  | 'context_length_exceeded_error'\n  | 'tool_permission_error'\n  | 'network_error'\n  | 'timeout_error'\n  | 'connection_refused_error'\n  | 'stream_aborted_error'\n  | 'validation_error';\n\n// Timeout error (convenience class)\nexport class TimeoutError extends NetworkError {\n  constructor(message: string, _timeout?: number) {\n    super(message, 'ETIMEDOUT');\n    this.name = 'TimeoutError';\n    Object.setPrototypeOf(this, TimeoutError.prototype);\n  }\n}\n\n// Validation error\nexport class ValidationError extends BaseSDKError {\n  constructor(\n    message: string,\n    public readonly field?: string,\n    public readonly value?: unknown\n  ) {\n    super(message);\n    this.name = 'ValidationError';\n    Object.setPrototypeOf(this, ValidationError.prototype);\n  }\n}\n\n// Error detection patterns\nexport const ErrorDetectionPatterns: Record<ErrorType, RegExp[]> = {\n  rate_limit_error: [\n    /rate[_\\s]?limit[_\\s]?exceeded/i,\n    /exceeded.*rate[_\\s]?limit/i,\n    /429/,\n    /too many requests/i\n  ],\n  authentication_error: [\n    /authentication[_\\s]?failed/i,\n    /401/,\n    /unauthorized/i,\n    /please[_\\s]?login/i\n  ],\n  model_not_available_error: [\n    /model[_\\s]?not[_\\s]?found/i,\n    /invalid[_\\s]?model/i,\n    /no such model/i\n  ],\n  context_length_exceeded_error: [\n    /context[_\\s]?length[_\\s]?exceeded/i,\n    /maximum[_\\s]?tokens/i,\n    /token[_\\s]?limit/i\n  ],\n  tool_permission_error: [\n    /tool[_\\s]?permission[_\\s]?denied/i,\n    /tool[_\\s]?not[_\\s]?allowed/i,\n    /permission[_\\s]?denied[_\\s]?for[_\\s]?tool/i\n  ],\n  network_error: [\n    /network[_\\s]?error/i,\n    /ENETWORK/i,\n    /EHOSTUNREACH/i\n  ],\n  timeout_error: [\n    /timeout/i,\n    /timed[_\\s]?out/i,\n    /ETIMEDOUT/i\n  ],\n  connection_refused_error: [\n    /connection[_\\s]?refused/i,\n    /ECONNREFUSED/i\n  ],\n  stream_aborted_error: [\n    /stream[_\\s]?aborted/i,\n    /aborted/i\n  ],\n  validation_error: [\n    /validation[_\\s]?error/i,\n    /validation[_\\s]?failed/i,\n    /invalid[_\\s]?parameter/i,\n    /invalid[_\\s]?argument/i,\n    /invalid[_\\s]?request/i\n  ],\n  api_error: [] // Catch-all, no specific patterns\n};\n\nexport const ERROR_PATTERNS: ErrorDetectionPattern[] = [\n  {\n    pattern: /rate[_\\s]?limit[_\\s]?exceeded|429|too many requests/i,\n    errorFactory: (_match, output) => {\n      const retryAfterMatch = output.match(/retry[_\\s]?after[:\\s]+(\\d+)/i);\n      const retryAfter = retryAfterMatch?.[1] ? parseInt(retryAfterMatch[1]) : 60;\n      return new RateLimitError('Rate limit exceeded', retryAfter);\n    }\n  },\n  {\n    pattern: /authentication[_\\s]?failed|401|unauthorized|please[_\\s]?login/i,\n    errorFactory: () => new AuthenticationError('Authentication failed', 'cli', 'Please run: claude login')\n  },\n  {\n    pattern: /model[_\\s]?not[_\\s]?found|invalid[_\\s]?model|no such model/i,\n    errorFactory: (_match, output) => {\n      const modelMatch = output.match(/model[:\\s]+\"?(\\w+)\"?/i);\n      const model = modelMatch?.[1] || 'unknown';\n      return new ModelNotAvailableError(model);\n    }\n  },\n  {\n    pattern: /context[_\\s]?length[_\\s]?exceeded|maximum[_\\s]?tokens|token[_\\s]?limit/i,\n    errorFactory: (_match, output) => {\n      const currentMatch = output.match(/current[:\\s]+(\\d+)/i);\n      const maxMatch = output.match(/max(?:imum)?[:\\s]+(\\d+)/i);\n      const current = currentMatch?.[1] ? parseInt(currentMatch[1]) : 0;\n      const max = maxMatch?.[1] ? parseInt(maxMatch[1]) : 0;\n      return new ContextLengthExceededError(current, max);\n    }\n  },\n  {\n    pattern: /tool[_\\s]?permission[_\\s]?denied|tool[_\\s]?not[_\\s]?allowed|permission[_\\s]?denied[_\\s]?for[_\\s]?tool/i,\n    errorFactory: (_match, output) => {\n      const toolMatch = output.match(/tool[:\\s]+\"?(\\w+)\"?|for[_\\s]?tool[:\\s]+\"?(\\w+)\"?/i);\n      const tool = toolMatch?.[1] || toolMatch?.[2] || 'unknown';\n      return new ToolPermissionError(tool, 'deny');\n    }\n  },\n  {\n    pattern: /connection[_\\s]?timeout|ETIMEDOUT|request[_\\s]?timeout/i,\n    errorFactory: (_match, output) => {\n      const timeoutMatch = output.match(/timeout[:\\s]+(\\d+)|after[_\\s]?(\\d+)ms/i);\n      const timeoutStr = timeoutMatch?.[1] || timeoutMatch?.[2];\n      const timeout = timeoutStr ? parseInt(timeoutStr) : 30000;\n      return new ConnectionTimeoutError(timeout);\n    }\n  },\n  {\n    pattern: /connection[_\\s]?refused|ECONNREFUSED/i,\n    errorFactory: () => new ConnectionRefusedError()\n  }\n];","// Base error class for all Claude SDK errors\nexport class ClaudeSDKError extends Error {\n  constructor(message: string, public readonly code?: string) {\n    super(message);\n    this.name = 'ClaudeSDKError';\n    Object.setPrototypeOf(this, ClaudeSDKError.prototype);\n  }\n}\n\n// Error when CLI connection fails\nexport class CLIConnectionError extends ClaudeSDKError {\n  constructor(message: string) {\n    super(message);\n    this.name = 'CLIConnectionError';\n    Object.setPrototypeOf(this, CLIConnectionError.prototype);\n  }\n}\n\n// Error when Claude Code CLI is not found\nexport class CLINotFoundError extends ClaudeSDKError {\n  constructor(message: string = 'Claude Code CLI not found. Please install it from https://github.com/anthropics/claude-code') {\n    super(message);\n    this.name = 'CLINotFoundError';\n    Object.setPrototypeOf(this, CLINotFoundError.prototype);\n  }\n}\n\n// Error when CLI process fails\nexport class ProcessError extends ClaudeSDKError {\n  constructor(\n    message: string,\n    public readonly exitCode?: number | null,\n    public readonly signal?: NodeJS.Signals | null\n  ) {\n    super(message);\n    this.name = 'ProcessError';\n    Object.setPrototypeOf(this, ProcessError.prototype);\n  }\n}\n\n// Error when operation is aborted via AbortSignal\nexport class AbortError extends ClaudeSDKError {\n  constructor(message: string = 'Operation was aborted') {\n    super(message, 'ABORT_ERROR');\n    this.name = 'AbortError';\n    Object.setPrototypeOf(this, AbortError.prototype);\n  }\n}\n\n// Error when JSON parsing fails\nexport class CLIJSONDecodeError extends ClaudeSDKError {\n  constructor(\n    message: string,\n    public readonly rawOutput: string\n  ) {\n    super(message);\n    this.name = 'CLIJSONDecodeError';\n    Object.setPrototypeOf(this, CLIJSONDecodeError.prototype);\n  }\n}\n\n// Error when configuration validation fails\nexport class ConfigValidationError extends ClaudeSDKError {\n  constructor(message: string) {\n    super(message);\n    this.name = 'ConfigValidationError';\n    Object.setPrototypeOf(this, ConfigValidationError.prototype);\n  }\n}\n\n// Re-export enhanced error types\nexport * from './types/enhanced-errors.js';\n\n// Import enhanced error types for detection\nimport {\n  APIError,\n  RateLimitError,\n  AuthenticationError,\n  ToolPermissionError,\n  NetworkError,\n  TimeoutError,\n  ValidationError,\n  StreamAbortedError,\n  type ErrorType,\n  ErrorDetectionPatterns\n} from './types/enhanced-errors.js';\n\n// Detect error type from message\nexport function detectErrorType(message: string): ErrorType {\n  // Check each pattern in order of specificity\n  for (const [errorType, patterns] of Object.entries(ErrorDetectionPatterns) as [ErrorType, RegExp[]][]) {\n    for (const pattern of patterns) {\n      if (pattern.test(message)) {\n        return errorType;\n      }\n    }\n  }\n  \n  return 'api_error'; // Default to generic API error\n}\n\n// Create typed error instance based on detection\nexport function createTypedError(\n  errorType: ErrorType,\n  message: string,\n  _originalError?: { code?: string; stack?: string }\n): Error {\n  switch (errorType) {\n    case 'rate_limit_error': {\n      // Extract retry info from message if possible\n      const retryMatch = message.match(/retry.?after[:\\s]+(\\d+)/i);\n      const retryAfter = retryMatch?.[1] ? parseInt(retryMatch[1]) : 60;\n      return new RateLimitError(message, retryAfter);\n    }\n      \n    case 'authentication_error':\n      return new AuthenticationError(message);\n      \n    case 'tool_permission_error': {\n      // Extract tool name from message if possible\n      const toolMatch = message.match(/tool[:\\s]+([\\w]+)/i);\n      const toolName = toolMatch?.[1] || 'unknown';\n      return new ToolPermissionError(toolName, 'deny', message);\n    }\n      \n    case 'network_error':\n      return new NetworkError(message);\n      \n    case 'timeout_error':\n      return new TimeoutError(message);\n      \n    case 'validation_error':\n      return new ValidationError(message);\n      \n    case 'stream_aborted_error':\n      return new StreamAbortedError(message);\n      \n    case 'api_error':\n    default: {\n      // Try to extract status code from message\n      const statusMatch = message.match(/\\b(4\\d{2}|5\\d{2})\\b/);\n      const statusCode = statusMatch?.[1] ? parseInt(statusMatch[1]) : undefined;\n      return new APIError(message, statusCode);\n    }\n  }\n}","import { type ExecaChildProcess } from 'execa';\nimport { AbortError } from '../../errors.js';\n\n/**\n * Manages proper subprocess cleanup when AbortSignal is triggered.\n * Addresses the Node.js console warning issue and ensures clean termination.\n */\nexport class SubprocessAbortHandler {\n  private cleanupHandler?: () => void;\n  private timeoutId?: NodeJS.Timeout;\n\n  constructor(\n    private process: ExecaChildProcess,\n    private signal?: AbortSignal\n  ) {}\n\n  /**\n   * Sets up abort handling with proper cleanup.\n   * Returns a cleanup function that should be called in finally blocks.\n   */\n  setup(): () => void {\n    if (!this.signal) {\n      return () => {};\n    }\n\n    // Check if already aborted\n    if (this.signal.aborted) {\n      this.process.cancel();\n      throw new AbortError('Operation aborted before starting');\n    }\n\n    // Create abort handler\n    this.cleanupHandler = () => {\n      // Use execa's cancel method for clean termination\n      this.process.cancel();\n      \n      // Set a fallback timeout for forceful termination\n      this.timeoutId = setTimeout(() => {\n        if (!this.process.killed) {\n          this.process.kill('SIGKILL');\n        }\n      }, 5000);\n    };\n\n    // Attach abort listener\n    this.signal.addEventListener('abort', this.cleanupHandler, { once: true });\n\n    // Handle process errors to prevent unhandled rejection warnings\n    const errorHandler = (error: Error) => {\n      // Only suppress abort-related errors\n      if (error.name === 'CancelError' || this.signal?.aborted) {\n        // This is expected when aborting, not a real error\n        return;\n      }\n      // Re-throw other errors\n      throw error;\n    };\n    this.process.on('error', errorHandler);\n\n    // Return cleanup function\n    return () => {\n      if (this.cleanupHandler) {\n        this.signal?.removeEventListener('abort', this.cleanupHandler);\n      }\n      if (this.timeoutId) {\n        clearTimeout(this.timeoutId);\n      }\n      this.process.removeListener('error', errorHandler);\n    };\n  }\n\n  /**\n   * Checks if the process was aborted\n   */\n  wasAborted(): boolean {\n    return this.signal?.aborted ?? false;\n  }\n}","/**\n * Safe environment variable loading for Claude Code SDK\n * \n * IMPORTANT: This module intentionally does NOT load API keys from environment\n * variables to prevent accidental billing charges. API keys must be explicitly\n * provided by the user.\n */\n\nimport type { SafeEnvironmentOptions } from './types/environment.js';\n\n/**\n * Parse boolean environment variable values\n */\nfunction parseBoolean(value: string | undefined): boolean | undefined {\n  if (value === undefined) return undefined;\n  \n  const normalized = value.toLowerCase().trim();\n  \n  // Handle common boolean representations\n  if (normalized === 'true' || normalized === '1' || normalized === 'yes' || normalized === 'on') {\n    return true;\n  }\n  \n  if (normalized === 'false' || normalized === '0' || normalized === 'no' || normalized === 'off') {\n    return false;\n  }\n  \n  // Invalid boolean value\n  return undefined;\n}\n\n/**\n * Parse and validate log level\n */\nfunction parseLogLevel(value: string | undefined): number | undefined {\n  if (value === undefined) return undefined;\n  \n  const level = parseInt(value, 10);\n  \n  // Validate range (0-4)\n  if (isNaN(level) || level < 0 || level > 4) {\n    return undefined;\n  }\n  \n  return level;\n}\n\n/**\n * Load safe environment variables\n * \n * This function loads only non-sensitive environment variables that are safe\n * to use for configuration. It explicitly does NOT load API keys.\n * \n * Supported environment variables:\n * - DEBUG: Enable debug mode (boolean)\n * - VERBOSE: Enable verbose output (boolean)\n * - LOG_LEVEL: Set log level 0-4 (number)\n * - NODE_ENV: Node environment (string)\n * \n * @returns Options loaded from environment variables\n */\nexport function loadSafeEnvironmentOptions(): SafeEnvironmentOptions {\n  const options: SafeEnvironmentOptions = {};\n  \n  // Load DEBUG\n  const debug = parseBoolean(process.env.DEBUG);\n  if (debug !== undefined) {\n    options.debug = debug;\n  }\n  \n  // Load VERBOSE\n  const verbose = parseBoolean(process.env.VERBOSE);\n  if (verbose !== undefined) {\n    options.verbose = verbose;\n  }\n  \n  // Load LOG_LEVEL\n  const logLevel = parseLogLevel(process.env.LOG_LEVEL);\n  if (logLevel !== undefined) {\n    options.logLevel = logLevel;\n  }\n  \n  // Load NODE_ENV\n  if (process.env.NODE_ENV) {\n    options.nodeEnv = process.env.NODE_ENV;\n  }\n  \n  // IMPORTANT: We do NOT load ANTHROPIC_API_KEY here\n  // This is a deliberate safety measure to prevent accidental billing\n  \n  return options;\n}\n\n/**\n * Warning message for API key safety\n */\nexport const API_KEY_SAFETY_WARNING = `\nIMPORTANT: API keys are not automatically loaded from environment variables.\nThis is a safety measure to prevent accidental billing charges.\n\nIf you need to use an API key, you must explicitly provide it in your code:\n  const result = await query('Your prompt', { apiKey: 'your-api-key' });\n\nIf you understand the risks and want to allow API key from environment:\n  const result = await query('Your prompt', { \n    apiKey: process.env.ANTHROPIC_API_KEY,\n    allowApiKeyFromEnv: true // Explicit opt-in\n  });\n`.trim();","/**\n * Options merger for combining user options with environment options\n */\n\nimport type { ClaudeCodeOptions } from '../types.js';\nimport type { SafeEnvironmentOptions } from '../types/environment.js';\n\n/**\n * Apply environment options to user options\n * \n * User options always take precedence over environment options.\n * This ensures explicit configuration overrides environment defaults.\n * \n * @param userOptions Options explicitly provided by the user\n * @param envOptions Options loaded from environment variables\n * @returns Merged options with user options taking precedence\n */\nexport function applyEnvironmentOptions(\n  userOptions: ClaudeCodeOptions,\n  envOptions: SafeEnvironmentOptions\n): ClaudeCodeOptions {\n  // Start with environment options as defaults\n  const merged: ClaudeCodeOptions = { ...userOptions };\n  \n  // Apply environment options only if not explicitly set by user\n  if (merged.debug === undefined && envOptions.debug !== undefined) {\n    merged.debug = envOptions.debug;\n  }\n  \n  // Apply verbose from env if not set\n  if (!('verbose' in merged) && envOptions.verbose !== undefined) {\n    (merged as any).verbose = envOptions.verbose;\n  }\n  \n  // Apply logLevel from env if not set\n  if (!('logLevel' in merged) && envOptions.logLevel !== undefined) {\n    (merged as any).logLevel = envOptions.logLevel;\n  }\n  \n  // Note: We don't apply nodeEnv to the options as it's not part of ClaudeCodeOptions\n  // It can be used internally for other purposes if needed\n  \n  return merged;\n}","import { SubprocessCLITransport } from './transport/subprocess-cli.js';\nimport type { ClaudeCodeOptions, Message, CLIOutput, AssistantMessage, CLIAssistantOutput, CLIErrorOutput } from '../types.js';\nimport { detectErrorType, createTypedError } from '../errors.js';\nimport { loadSafeEnvironmentOptions } from '../environment.js';\nimport { applyEnvironmentOptions } from './options-merger.js';\n\nexport class InternalClient {\n  private options: ClaudeCodeOptions;\n  private prompt: string;\n\n  constructor(prompt: string, options: ClaudeCodeOptions = {}) {\n    this.prompt = prompt;\n    \n    // Load safe environment variables and merge with user options\n    const envOptions = loadSafeEnvironmentOptions();\n    this.options = applyEnvironmentOptions(options, envOptions);\n  }\n\n  async *processQuery(): AsyncGenerator<Message> {\n    const transport = new SubprocessCLITransport(this.prompt, this.options);\n\n    try {\n      await transport.connect();\n\n      for await (const output of transport.receiveMessages()) {\n        const message = this.parseMessage(output);\n        if (message) {\n          yield message;\n        }\n      }\n    } finally {\n      await transport.disconnect();\n    }\n  }\n\n  private parseMessage(output: CLIOutput): Message | null {\n    // Handle CLIOutput types based on actual CLI output\n    switch (output.type) {\n      case 'assistant': {\n        // Extract the actual assistant message from the wrapper\n        const assistantMsg = output as CLIAssistantOutput;\n        if (assistantMsg.message) {\n          // Return a simplified assistant message with just the content\n          return {\n            type: 'assistant',\n            content: assistantMsg.message.content,\n            session_id: assistantMsg.session_id\n          } as AssistantMessage;\n        }\n        return {\n          type: 'assistant',\n          content: [],\n          session_id: assistantMsg.session_id\n        } as AssistantMessage;\n      }\n        \n      case 'system':\n        // System messages (like init) - skip these\n        return null;\n        \n      case 'result': {\n        // Result message with usage stats - return it\n        const resultMsg = output as any; // Type assertion for now\n        return {\n          type: 'result',\n          subtype: resultMsg.subtype,\n          content: resultMsg.content || '',\n          session_id: resultMsg.session_id,\n          usage: resultMsg.usage,\n          cost: {\n            total_cost: resultMsg.cost?.total_cost_usd\n          }\n        } as Message;\n      }\n        \n      case 'error': {\n        const errorOutput = output as CLIErrorOutput;\n        const errorMessage = errorOutput.error?.message || 'Unknown error';\n        const errorType = detectErrorType(errorMessage);\n        throw createTypedError(errorType, errorMessage, errorOutput.error);\n      }\n      \n      default:\n        // Skip unknown message types\n        return null;\n    }\n  }\n}","/**\n * OpenTelemetry integration interfaces for observability\n */\n\nimport type { Logger } from '../logger.js';\nimport type { ClaudeCodeOptions } from '../types.js';\n\n// Telemetry context for distributed tracing\nexport interface TelemetryContext {\n  /** Trace ID for distributed tracing */\n  traceId?: string;\n  /** Span ID for the current operation */\n  spanId?: string;\n  /** Parent span ID */\n  parentSpanId?: string;\n  /** User ID for attribution */\n  userId?: string;\n  /** Session ID for grouping */\n  sessionId?: string;\n  /** Additional baggage */\n  baggage?: Record<string, string>;\n}\n\n// Span status\nexport type SpanStatus = 'unset' | 'ok' | 'error';\n\n// Span kind\nexport type SpanKind = 'internal' | 'server' | 'client' | 'producer' | 'consumer';\n\n// Telemetry span interface\nexport interface TelemetrySpan {\n  /** End the span */\n  end(): void;\n  /** Set span status */\n  setStatus(status: SpanStatus, message?: string): void;\n  /** Add an event to the span */\n  addEvent(name: string, attributes?: Record<string, any>): void;\n  /** Set an attribute on the span */\n  setAttribute(key: string, value: unknown): void;\n  /** Set multiple attributes */\n  setAttributes(attributes: Record<string, any>): void;\n  /** Record an exception */\n  recordException(error: Error): void;\n  /** Get span context */\n  getSpanContext(): TelemetryContext;\n  /** Update span name */\n  updateName(name: string): void;\n}\n\n// Enhanced logger interface with telemetry support\nexport interface TelemetryLogger extends Logger {\n  /** Start a new span */\n  startSpan(name: string, options?: SpanOptions): TelemetrySpan;\n  /** Record a metric */\n  recordMetric(name: string, value: number, labels?: Record<string, string>): void;\n  /** Set telemetry context */\n  setContext(context: TelemetryContext): void;\n  /** Get current context */\n  getContext(): TelemetryContext | undefined;\n  /** Create a child logger with context */\n  child(context: TelemetryContext): TelemetryLogger;\n}\n\n// Span options\nexport interface SpanOptions {\n  /** Parent context */\n  parent?: TelemetryContext;\n  /** Span kind */\n  kind?: SpanKind;\n  /** Initial attributes */\n  attributes?: Record<string, any>;\n  /** Start time (if not now) */\n  startTime?: number;\n  /** Links to other spans */\n  links?: SpanLink[];\n}\n\n// Link to another span\nexport interface SpanLink {\n  /** Context of the linked span */\n  context: TelemetryContext;\n  /** Attributes for the link */\n  attributes?: Record<string, any>;\n}\n\n// Metric types\nexport type MetricType = 'counter' | 'gauge' | 'histogram' | 'summary';\n\n// Metric definition\nexport interface MetricDefinition {\n  /** Metric name */\n  name: string;\n  /** Metric type */\n  type: MetricType;\n  /** Description */\n  description?: string;\n  /** Unit of measurement */\n  unit?: string;\n  /** Value boundaries for histogram */\n  boundaries?: number[];\n}\n\n// Query metrics\nexport interface QueryMetrics {\n  /** Total number of queries */\n  totalQueries: number;\n  /** Successful queries */\n  successfulQueries: number;\n  /** Failed queries */\n  failedQueries: number;\n  /** Total tokens used */\n  totalTokens: number;\n  /** Input tokens */\n  inputTokens: number;\n  /** Output tokens */\n  outputTokens: number;\n  /** Cache hits */\n  cacheHits: number;\n  /** Cache misses */\n  cacheMisses: number;\n  /** Average query duration in ms */\n  averageQueryDuration: number;\n  /** P95 query duration in ms */\n  p95QueryDuration: number;\n  /** P99 query duration in ms */\n  p99QueryDuration: number;\n}\n\n// Tool execution metrics\nexport interface ToolMetrics {\n  /** Tool name */\n  tool: string;\n  /** Number of executions */\n  executionCount: number;\n  /** Number of failures */\n  failureCount: number;\n  /** Average execution time in ms */\n  averageExecutionTime: number;\n  /** Total execution time in ms */\n  totalExecutionTime: number;\n  /** Error rate */\n  errorRate: number;\n}\n\n// Telemetry provider interface\nexport interface TelemetryProvider {\n  /** Initialize the provider */\n  initialize(config: TelemetryConfig): Promise<void>;\n  /** Get a logger instance */\n  getLogger(name?: string): TelemetryLogger;\n  /** Shutdown the provider */\n  shutdown(): Promise<void>;\n  /** Force flush all pending data */\n  forceFlush(): Promise<void>;\n  /** Get query metrics */\n  getQueryMetrics(): QueryMetrics;\n  /** Get tool metrics */\n  getToolMetrics(): Map<string, ToolMetrics>;\n}\n\n// Telemetry configuration\nexport interface TelemetryConfig {\n  /** Service name */\n  serviceName: string;\n  /** Service version */\n  serviceVersion?: string;\n  /** Environment */\n  environment?: string;\n  /** General endpoint (can be used for both traces and metrics) */\n  endpoint?: string;\n  /** Endpoint for traces */\n  traceEndpoint?: string;\n  /** Endpoint for metrics */\n  metricsEndpoint?: string;\n  /** Headers for authentication */\n  headers?: Record<string, string>;\n  /** Export interval in ms */\n  exportInterval?: number;\n  /** Batch size for export */\n  batchSize?: number;\n  /** Additional resource attributes */\n  resourceAttributes?: Record<string, any>;\n  /** Sampling configuration */\n  sampling?: SamplingConfig;\n  /** Enable auto-instrumentation */\n  autoInstrumentation?: boolean;\n}\n\n// Sampling configuration\nexport interface SamplingConfig {\n  /** Sampling strategy */\n  strategy: 'always' | 'never' | 'probability' | 'adaptive';\n  /** Probability for probability sampling (0-1) */\n  probability?: number;\n  /** Rate limit for adaptive sampling */\n  rateLimit?: number;\n  /** Rules for specific operations */\n  rules?: SamplingRule[];\n}\n\n// Sampling rule\nexport interface SamplingRule {\n  /** Operation name pattern */\n  operation: string | RegExp;\n  /** Sampling probability for this operation */\n  probability: number;\n}\n\n// Telemetry events\nexport interface TelemetryEvents {\n  /** Query lifecycle events */\n  query: {\n    start: QueryStartEvent;\n    end: QueryEndEvent;\n    error: QueryErrorEvent;\n  };\n  /** Tool execution events */\n  tool: {\n    start: ToolStartEvent;\n    end: ToolEndEvent;\n    error: ToolErrorEvent;\n  };\n  /** Stream events */\n  stream: {\n    start: StreamStartEvent;\n    chunk: StreamChunkEvent;\n    end: StreamEndEvent;\n    abort: StreamAbortEvent;\n  };\n}\n\n// Query start event\nexport interface QueryStartEvent {\n  /** Unique query ID */\n  queryId: string;\n  /** Prompt */\n  prompt: string;\n  /** Options */\n  options: ClaudeCodeOptions;\n  /** Timestamp */\n  timestamp: number;\n  /** Parent context */\n  parentContext?: TelemetryContext;\n}\n\n// Query end event\nexport interface QueryEndEvent {\n  /** Query ID */\n  queryId: string;\n  /** Duration in ms */\n  duration: number;\n  /** Token usage */\n  usage?: {\n    input_tokens?: number;\n    output_tokens?: number;\n    cache_creation_input_tokens?: number;\n    cache_read_input_tokens?: number;\n  };\n  /** Success status */\n  success: boolean;\n  /** Result summary */\n  resultSummary?: string;\n  /** Error if failed */\n  error?: Error;\n}\n\n// Query error event\nexport interface QueryErrorEvent {\n  /** Query ID */\n  queryId: string;\n  /** Error */\n  error: Error;\n  /** Error type */\n  errorType: string;\n  /** Retry attempt */\n  retryAttempt?: number;\n}\n\n// Tool start event\nexport interface ToolStartEvent {\n  /** Tool use ID */\n  toolUseId: string;\n  /** Tool name */\n  tool: string;\n  /** Tool input */\n  input: unknown;\n  /** Parent query ID */\n  queryId: string;\n  /** Timestamp */\n  timestamp: number;\n}\n\n// Tool end event\nexport interface ToolEndEvent {\n  /** Tool use ID */\n  toolUseId: string;\n  /** Tool name */\n  tool: string;\n  /** Duration in ms */\n  duration: number;\n  /** Success status */\n  success: boolean;\n  /** Result size in bytes */\n  resultSize?: number;\n  /** Error if failed */\n  error?: Error;\n}\n\n// Tool error event\nexport interface ToolErrorEvent {\n  /** Tool use ID */\n  toolUseId: string;\n  /** Error */\n  error: Error;\n  /** Error type */\n  errorType: string;\n}\n\n// Stream start event\nexport interface StreamStartEvent {\n  /** Stream ID */\n  streamId: string;\n  /** Parent query ID */\n  queryId: string;\n  /** Expected chunks */\n  expectedChunks?: number;\n  /** Timestamp */\n  timestamp: number;\n}\n\n// Stream chunk event\nexport interface StreamChunkEvent {\n  /** Stream ID */\n  streamId: string;\n  /** Chunk index */\n  chunkIndex: number;\n  /** Chunk size in bytes */\n  chunkSize: number;\n  /** Chunk type */\n  chunkType: 'text' | 'tool_use' | 'tool_result';\n}\n\n// Stream end event\nexport interface StreamEndEvent {\n  /** Stream ID */\n  streamId: string;\n  /** Total chunks */\n  totalChunks: number;\n  /** Total bytes */\n  totalBytes: number;\n  /** Duration in ms */\n  duration: number;\n}\n\n// Stream abort event\nexport interface StreamAbortEvent {\n  /** Stream ID */\n  streamId: string;\n  /** Abort reason */\n  reason: string;\n  /** Chunks received before abort */\n  chunksReceived: number;\n}\n\n// Built-in metric definitions\nexport const BUILTIN_METRICS: Record<string, MetricDefinition> = {\n  queries: {\n    name: 'claude_sdk_queries_total',\n    type: 'counter',\n    description: 'Total number of queries',\n    unit: 'query'\n  },\n  queryDuration: {\n    name: 'claude_sdk_query_duration',\n    type: 'histogram',\n    description: 'Query duration',\n    unit: 'ms',\n    boundaries: [10, 50, 100, 500, 1000, 5000, 10000, 30000, 60000]\n  },\n  tokens: {\n    name: 'claude_sdk_tokens_total',\n    type: 'counter',\n    description: 'Total tokens used',\n    unit: 'token'\n  },\n  toolExecutions: {\n    name: 'claude_sdk_tool_executions_total',\n    type: 'counter',\n    description: 'Total tool executions',\n    unit: 'execution'\n  },\n  toolDuration: {\n    name: 'claude_sdk_tool_duration',\n    type: 'histogram',\n    description: 'Tool execution duration',\n    unit: 'ms',\n    boundaries: [1, 5, 10, 50, 100, 500, 1000, 5000]\n  },\n  errors: {\n    name: 'claude_sdk_errors_total',\n    type: 'counter',\n    description: 'Total errors',\n    unit: 'error'\n  },\n  retries: {\n    name: 'claude_sdk_retries_total',\n    type: 'counter',\n    description: 'Total retry attempts',\n    unit: 'retry'\n  },\n  activeStreams: {\n    name: 'claude_sdk_active_streams',\n    type: 'gauge',\n    description: 'Number of active streams',\n    unit: 'stream'\n  }\n};\n\n// Telemetry utilities\nexport class TelemetryUtils {\n  /** Extract trace context from headers */\n  static extractTraceContext(headers: Record<string, string>): TelemetryContext | undefined {\n    const traceId = headers['x-trace-id'] || headers['traceparent']?.split('-')[1];\n    const spanId = headers['x-span-id'] || headers['traceparent']?.split('-')[2];\n    \n    if (!traceId) return undefined;\n    \n    return {\n      traceId,\n      spanId,\n      baggage: this.extractBaggage(headers)\n    };\n  }\n  \n  /** Inject trace context into headers */\n  static injectTraceContext(context: TelemetryContext, headers: Record<string, string>): void {\n    if (context.traceId) {\n      headers['x-trace-id'] = context.traceId;\n      if (context.spanId) {\n        headers['x-span-id'] = context.spanId;\n        headers['traceparent'] = `00-${context.traceId}-${context.spanId}-01`;\n      }\n    }\n    \n    if (context.baggage) {\n      headers['baggage'] = Object.entries(context.baggage)\n        .map(([k, v]) => `${k}=${v}`)\n        .join(',');\n    }\n  }\n  \n  /** Extract baggage from headers */\n  private static extractBaggage(headers: Record<string, string>): Record<string, string> | undefined {\n    const baggage = headers['baggage'];\n    if (!baggage) return undefined;\n    \n    const result: Record<string, string> = {};\n    baggage.split(',').forEach(item => {\n      const [key, value] = item.split('=');\n      if (key && value) {\n        result[key.trim()] = value.trim();\n      }\n    });\n    \n    return Object.keys(result).length > 0 ? result : undefined;\n  }\n}","/**\n * Retry and backoff interfaces for resilient API calls\n */\n\n// Types for retry functionality\n\n// Retry configuration options\nexport interface RetryOptions {\n  /** Maximum number of retry attempts */\n  maxAttempts?: number;\n  /** Initial delay in milliseconds */\n  initialDelay?: number;\n  /** Maximum delay in milliseconds */\n  maxDelay?: number;\n  /** Backoff multiplier */\n  multiplier?: number;\n  /** Add random jitter to delays */\n  jitter?: boolean;\n  /** Jitter factor (0-1) */\n  jitterFactor?: number;\n  /** List of retryable error types */\n  retryableErrors?: Array<new (...args: unknown[]) => Error>;\n  /** Custom retry predicate */\n  shouldRetry?: (error: Error, attempt: number) => boolean;\n  /** Callback on each retry attempt */\n  onRetry?: (attempt: number, error: Error, nextDelay: number) => void | Promise<void>;\n  /** Abort signal for cancellation */\n  signal?: AbortSignal;\n  /** Timeout for individual attempts */\n  attemptTimeout?: number;\n  /** Total timeout for all attempts */\n  totalTimeout?: number;\n}\n\n// Retry result with metadata\nexport interface RetryResult<T> {\n  /** The successful result */\n  value: T;\n  /** Number of attempts made */\n  attempts: number;\n  /** Total time spent retrying */\n  totalDuration: number;\n  /** Errors encountered during retries */\n  errors: Error[];\n}\n\n// Backoff strategy types\nexport type BackoffStrategy = \n  | 'exponential'\n  | 'linear'\n  | 'constant'\n  | 'fibonacci'\n  | 'polynomial';\n\n// Advanced retry configuration\nexport interface AdvancedRetryOptions extends RetryOptions {\n  /** Backoff strategy to use */\n  strategy?: BackoffStrategy;\n  /** Polynomial degree for polynomial backoff */\n  polynomialDegree?: number;\n  /** Base for exponential backoff */\n  exponentialBase?: number;\n  /** Rate limiting */\n  rateLimit?: RateLimitOptions;\n  /** Circuit breaker integration */\n  circuitBreaker?: CircuitBreakerOptions;\n}\n\n// Rate limiting options\nexport interface RateLimitOptions {\n  /** Maximum requests per window */\n  maxRequests: number;\n  /** Time window in milliseconds */\n  windowMs: number;\n  /** Strategy when rate limited */\n  strategy: 'delay' | 'drop' | 'queue';\n  /** Maximum queue size for 'queue' strategy */\n  maxQueueSize?: number;\n}\n\n// Circuit breaker options\nexport interface CircuitBreakerOptions {\n  /** Failure threshold to open circuit */\n  failureThreshold: number;\n  /** Success threshold to close circuit */\n  successThreshold?: number;\n  /** Timeout before attempting half-open */\n  resetTimeout: number;\n  /** Requests allowed in half-open state */\n  halfOpenLimit?: number;\n  /** Callback when circuit opens */\n  onOpen?: (failures: number) => void;\n  /** Callback when circuit closes */\n  onClose?: () => void;\n  /** Callback when circuit enters half-open */\n  onHalfOpen?: () => void;\n}\n\n// Circuit breaker states\nexport type CircuitState = 'closed' | 'open' | 'half-open';\n\n// Circuit breaker interface\nexport interface CircuitBreaker {\n  /** Current state */\n  readonly state: CircuitState;\n  /** Execute function with circuit breaker */\n  execute<T>(fn: () => Promise<T>): Promise<T>;\n  /** Reset the circuit breaker */\n  reset(): void;\n  /** Get circuit statistics */\n  getStats(): CircuitBreakerStats;\n}\n\n// Circuit breaker statistics\nexport interface CircuitBreakerStats {\n  /** Current state */\n  state: CircuitState;\n  /** Total requests */\n  totalRequests: number;\n  /** Successful requests */\n  successfulRequests: number;\n  /** Failed requests */\n  failedRequests: number;\n  /** Consecutive failures */\n  consecutiveFailures: number;\n  /** Consecutive successes */\n  consecutiveSuccesses: number;\n  /** Last failure time */\n  lastFailureTime?: number;\n  /** Last success time */\n  lastSuccessTime?: number;\n  /** Time circuit opened */\n  openedAt?: number;\n  /** Next retry time (if open) */\n  nextRetryAt?: number;\n}\n\n// Retry strategy interface\nexport interface RetryStrategy {\n  /** Calculate next delay */\n  calculateDelay(attempt: number, baseDelay: number): number;\n  /** Check if should retry */\n  shouldRetry(error: Error, attempt: number): boolean;\n  /** Reset strategy state */\n  reset(): void;\n}\n\n// Exponential backoff strategy\nexport class ExponentialBackoffStrategy implements RetryStrategy {\n  constructor(\n    private options: {\n      multiplier?: number;\n      maxDelay?: number;\n      jitter?: boolean;\n      jitterFactor?: number;\n      base?: number;\n    } = {}\n  ) {}\n  \n  calculateDelay(attempt: number, baseDelay: number): number {\n    const multiplier = this.options.multiplier || 2;\n    const base = this.options.base || multiplier;\n    const maxDelay = this.options.maxDelay || 60000;\n    \n    let delay = baseDelay * Math.pow(base, attempt - 1);\n    delay = Math.min(delay, maxDelay);\n    \n    if (this.options.jitter) {\n      const jitterFactor = this.options.jitterFactor || 0.1;\n      const jitterRange = delay * jitterFactor;\n      const jitter = (Math.random() - 0.5) * 2 * jitterRange;\n      delay = Math.max(0, delay + jitter);\n    }\n    \n    return Math.round(delay);\n  }\n  \n  shouldRetry(_error: Error, _attempt: number): boolean {\n    // Default implementation - let options handle this\n    return true;\n  }\n  \n  reset(): void {\n    // No state to reset in exponential backoff\n  }\n}\n\n// Linear backoff strategy\nexport class LinearBackoffStrategy implements RetryStrategy {\n  constructor(\n    private options: {\n      increment?: number;\n      maxDelay?: number;\n      jitter?: boolean;\n    } = {}\n  ) {}\n  \n  calculateDelay(attempt: number, baseDelay: number): number {\n    const increment = this.options.increment || baseDelay;\n    const maxDelay = this.options.maxDelay || 60000;\n    \n    let delay = baseDelay + (increment * (attempt - 1));\n    delay = Math.min(delay, maxDelay);\n    \n    if (this.options.jitter) {\n      const jitter = (Math.random() - 0.5) * 0.2 * delay;\n      delay = Math.max(0, delay + jitter);\n    }\n    \n    return Math.round(delay);\n  }\n  \n  shouldRetry(_error: Error, _attempt: number): boolean {\n    return true;\n  }\n  \n  reset(): void {\n    // No state to reset\n  }\n}\n\n// Fibonacci backoff strategy\nexport class FibonacciBackoffStrategy implements RetryStrategy {\n  private sequence: number[] = [1, 1];\n  \n  constructor(\n    private options: {\n      maxDelay?: number;\n      jitter?: boolean;\n    } = {}\n  ) {}\n  \n  calculateDelay(attempt: number, baseDelay: number): number {\n    const maxDelay = this.options.maxDelay || 60000;\n    \n    // Generate Fibonacci sequence up to attempt\n    while (this.sequence.length < attempt) {\n      const len = this.sequence.length;\n      if (len >= 2) {\n        const next = this.sequence[len - 1]! + this.sequence[len - 2]!;\n        this.sequence.push(next);\n      }\n    }\n    \n    const fibValue = this.sequence[attempt - 1] ?? 1;\n    let delay = baseDelay * fibValue;\n    delay = Math.min(delay, maxDelay);\n    \n    if (this.options.jitter) {\n      const jitter = (Math.random() - 0.5) * 0.2 * delay;\n      delay = Math.max(0, delay + jitter);\n    }\n    \n    return Math.round(delay);\n  }\n  \n  shouldRetry(_error: Error, _attempt: number): boolean {\n    return true;\n  }\n  \n  reset(): void {\n    this.sequence = [1, 1];\n  }\n}\n\n// Retry executor interface\nexport interface RetryExecutor {\n  /** Execute function with retry logic */\n  execute<T>(fn: () => Promise<T>, options?: RetryOptions): Promise<T>;\n  /** Execute with detailed result */\n  executeWithResult<T>(fn: () => Promise<T>, options?: RetryOptions): Promise<RetryResult<T>>;\n  /** Set default options */\n  setDefaults(options: RetryOptions): void;\n  /** Get statistics */\n  getStats(): RetryExecutorStats;\n  /** Reset statistics */\n  resetStats(): void;\n}\n\n// Retry executor statistics\nexport interface RetryExecutorStats {\n  /** Total executions */\n  totalExecutions: number;\n  /** Successful on first attempt */\n  successfulFirstAttempts: number;\n  /** Successful after retry */\n  successfulRetries: number;\n  /** Failed after all retries */\n  totalFailures: number;\n  /** Total retry attempts */\n  totalRetryAttempts: number;\n  /** Average attempts per execution */\n  averageAttempts: number;\n  /** Maximum attempts for any execution */\n  maxAttempts: number;\n}\n\n// Retry utilities\nexport class RetryUtils {\n  /** Default retryable errors */\n  static readonly DEFAULT_RETRYABLE_ERRORS = [\n    'NetworkError',\n    'TimeoutError',\n    'RateLimitError',\n    'ServiceUnavailableError'\n  ];\n  \n  /** Check if error is retryable by default */\n  static isRetryableError(error: Error): boolean {\n    // Check error name\n    if (this.DEFAULT_RETRYABLE_ERRORS.includes(error.name)) {\n      return true;\n    }\n    \n    // Check error message patterns\n    const retryablePatterns = [\n      /timeout/i,\n      /rate.?limit/i,\n      /too.?many.?requests/i,\n      /service.?unavailable/i,\n      /gateway.?timeout/i,\n      /ECONNREFUSED/,\n      /ETIMEDOUT/,\n      /ENOTFOUND/\n    ];\n    \n    return retryablePatterns.some(pattern => pattern.test(error.message));\n  }\n  \n  /** Sleep for specified milliseconds */\n  static sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n  \n  /** Create retry function with defaults */\n  static withRetry<T>(\n    fn: () => Promise<T>,\n    options: RetryOptions = {}\n  ): () => Promise<T> {\n    return async () => {\n      const executor = new SimpleRetryExecutor();\n      return executor.execute(fn, options);\n    };\n  }\n}\n\n// Simple retry executor implementation\nexport class SimpleRetryExecutor implements RetryExecutor {\n  private defaults: RetryOptions = {\n    maxAttempts: 3,\n    initialDelay: 1000,\n    maxDelay: 30000,\n    multiplier: 2,\n    jitter: true\n  };\n  \n  private stats: RetryExecutorStats = {\n    totalExecutions: 0,\n    successfulFirstAttempts: 0,\n    successfulRetries: 0,\n    totalFailures: 0,\n    totalRetryAttempts: 0,\n    averageAttempts: 0,\n    maxAttempts: 0\n  };\n  \n  async execute<T>(fn: () => Promise<T>, options?: RetryOptions): Promise<T> {\n    const result = await this.executeWithResult(fn, options);\n    return result.value;\n  }\n  \n  async executeWithResult<T>(\n    fn: () => Promise<T>,\n    options?: RetryOptions\n  ): Promise<RetryResult<T>> {\n    const opts = { ...this.defaults, ...options };\n    const errors: Error[] = [];\n    const startTime = Date.now();\n    \n    this.stats.totalExecutions++;\n    \n    for (let attempt = 1; attempt <= (opts.maxAttempts || 3); attempt++) {\n      try {\n        const value = await fn();\n        \n        // Success\n        if (attempt === 1) {\n          this.stats.successfulFirstAttempts++;\n        } else {\n          this.stats.successfulRetries++;\n        }\n        \n        this.updateStats(attempt);\n        \n        return {\n          value,\n          attempts: attempt,\n          totalDuration: Date.now() - startTime,\n          errors\n        };\n      } catch (error) {\n        errors.push(error as Error);\n        \n        // Check if should retry\n        const shouldRetry = this.shouldRetry(error as Error, attempt, opts);\n        \n        if (!shouldRetry || attempt === opts.maxAttempts) {\n          this.stats.totalFailures++;\n          this.updateStats(attempt);\n          throw error;\n        }\n        \n        // Calculate delay\n        const delay = this.calculateDelay(attempt, opts);\n        \n        // Call retry callback\n        if (opts.onRetry) {\n          await opts.onRetry(attempt, error as Error, delay);\n        }\n        \n        // Wait before retry\n        await RetryUtils.sleep(delay);\n        this.stats.totalRetryAttempts++;\n      }\n    }\n    \n    // Should never reach here\n    throw errors[errors.length - 1];\n  }\n  \n  setDefaults(options: RetryOptions): void {\n    this.defaults = { ...this.defaults, ...options };\n  }\n  \n  getStats(): RetryExecutorStats {\n    return { ...this.stats };\n  }\n  \n  resetStats(): void {\n    this.stats = {\n      totalExecutions: 0,\n      successfulFirstAttempts: 0,\n      successfulRetries: 0,\n      totalFailures: 0,\n      totalRetryAttempts: 0,\n      averageAttempts: 0,\n      maxAttempts: 0\n    };\n  }\n  \n  private shouldRetry(error: Error, attempt: number, options: RetryOptions): boolean {\n    if (options.shouldRetry) {\n      return options.shouldRetry(error, attempt);\n    }\n    \n    if (options.retryableErrors) {\n      return options.retryableErrors.some(ErrorClass => error instanceof ErrorClass);\n    }\n    \n    return RetryUtils.isRetryableError(error);\n  }\n  \n  private calculateDelay(attempt: number, options: RetryOptions): number {\n    const strategy = new ExponentialBackoffStrategy({\n      multiplier: options.multiplier,\n      maxDelay: options.maxDelay,\n      jitter: options.jitter,\n      jitterFactor: options.jitterFactor\n    });\n    \n    return strategy.calculateDelay(attempt, options.initialDelay || 1000);\n  }\n  \n  private updateStats(attempts: number): void {\n    this.stats.maxAttempts = Math.max(this.stats.maxAttempts, attempts);\n    \n    const totalAttempts = this.stats.successfulFirstAttempts + \n                         (this.stats.successfulRetries * 2) + // At least 2 attempts\n                         (this.stats.totalFailures * (this.defaults.maxAttempts || 3));\n    \n    this.stats.averageAttempts = totalAttempts / this.stats.totalExecutions;\n  }\n}","/**\n * Environment and error utility types\n */\n\nexport interface SafeEnvironmentOptions {\n  debug?: boolean;\n  verbose?: boolean;\n  logLevel?: number;\n  nodeEnv?: string;\n}\n\nexport type ErrorCategory = \n  | 'auth' \n  | 'network' \n  | 'timeout' \n  | 'validation' \n  | 'subprocess' \n  | 'parsing' \n  | 'permission' \n  | 'configuration' \n  | 'unknown';\n\nexport interface EnhancedErrorOptions {\n  category: ErrorCategory;\n  context?: Record<string, unknown>;\n  retryable?: boolean;\n  resolution?: string;\n  helpUrl?: string;\n  statusCode?: number;\n  cause?: Error;\n}\n\nexport interface IEnhancedError extends Error {\n  category: ErrorCategory;\n  resolution?: string;\n  statusCode?: number;\n  cause?: Error;\n  context?: Record<string, unknown>;\n}\n\n/**\n * Type guard to check if an error is an enhanced error\n */\nexport function isEnhancedError(error: unknown): error is Error & EnhancedErrorOptions {\n  return error instanceof Error && \n    'category' in error && \n    typeof (error as any).category === 'string';\n}\n\n/**\n * Check if an error has resolution information\n */\nexport function hasResolution(error: unknown): boolean {\n  return isEnhancedError(error) && \n    !!error.resolution && \n    typeof error.resolution === 'string';\n}","import type { Message, ToolUseBlock, ResultMessage } from './types.js';\nimport type { Logger } from './logger.js';\n\n/**\n * Response parser for extracting and transforming Claude messages\n * Provides convenient methods for common parsing patterns\n * \n * @example\n * ```typescript\n * const result = await claude()\n *   .query('Create a hello.txt file')\n *   .asText(); // Returns just the text content\n * \n * const files = await claude()\n *   .query('Read all config files')\n *   .findToolResults('Read'); // Returns all Read tool results\n * ```\n */\nexport class ResponseParser {\n  private messages: Message[] = [];\n  private consumed = false;\n\n  constructor(\n    private generator: AsyncGenerator<Message>,\n    private handlers: Array<(message: Message) => void> = [],\n    private logger?: Logger\n  ) {}\n\n  /**\n   * Get all messages as an array (consumes the generator)\n   */\n  async asArray(): Promise<Message[]> {\n    await this.consume();\n    return this.messages;\n  }\n\n  /**\n   * Get only the text content from assistant messages\n   */\n  async asText(): Promise<string> {\n    await this.consume();\n    \n    const texts: string[] = [];\n    for (const msg of this.messages) {\n      if (msg.type === 'assistant') {\n        for (const block of msg.content) {\n          if (block.type === 'text') {\n            texts.push(block.text);\n          }\n        }\n      }\n    }\n    \n    return texts.join('\\n');\n  }\n\n  /**\n   * Get the final result message content\n   */\n  async asResult(): Promise<string | null> {\n    await this.consume();\n    \n    const resultMsg = this.messages.findLast((msg): msg is ResultMessage => msg.type === 'result');\n    return resultMsg?.content ?? null;\n  }\n\n  /**\n   * Get all tool uses with their results\n   */\n  async asToolExecutions(): Promise<ToolExecution[]> {\n    await this.consume();\n    \n    const executions: ToolExecution[] = [];\n    const toolUses = new Map<string, ToolUseBlock>();\n    \n    for (const msg of this.messages) {\n      if (msg.type === 'assistant') {\n        for (const block of msg.content) {\n          if (block.type === 'tool_use') {\n            toolUses.set(block.id, block);\n          } else if (block.type === 'tool_result') {\n            const toolUse = toolUses.get(block.tool_use_id);\n            if (toolUse) {\n              executions.push({\n                tool: toolUse.name,\n                input: toolUse.input,\n                result: block.content,\n                isError: block.is_error ?? false\n              });\n            }\n          }\n        }\n      }\n    }\n    \n    return executions;\n  }\n\n  /**\n   * Find all tool results for a specific tool\n   */\n  async findToolResults(toolName: string): Promise<unknown[]> {\n    const executions = await this.asToolExecutions();\n    return executions\n      .filter(exec => exec.tool === toolName && !exec.isError)\n      .map(exec => exec.result);\n  }\n\n  /**\n   * Get first tool result for a specific tool\n   */\n  async findToolResult(toolName: string): Promise<unknown | null> {\n    const results = await this.findToolResults(toolName);\n    return results[0] ?? null;\n  }\n\n  /**\n   * Extract structured data from the response\n   */\n  async asJSON<T = unknown>(): Promise<T | null> {\n    const text = await this.asText();\n    \n    // Try to find JSON in code blocks first\n    const codeBlockMatch = text.match(/```(?:json)?\\n([\\s\\S]*?)\\n```/);\n    if (codeBlockMatch) {\n      try {\n        return JSON.parse(codeBlockMatch[1] ?? '');\n      } catch (e) {\n        this.logger?.warn('Failed to parse JSON from code block', { error: e });\n      }\n    }\n    \n    // Try to parse the entire text as JSON\n    try {\n      return JSON.parse(text);\n    } catch {\n      // Try to find JSON-like content\n      const jsonMatch = text.match(/\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\]/);\n      if (jsonMatch) {\n        try {\n          return JSON.parse(jsonMatch[0]);\n        } catch (e) {\n          this.logger?.warn('Failed to parse JSON from text', { error: e });\n        }\n      }\n    }\n    \n    return null;\n  }\n\n  /**\n   * Get usage statistics\n   */\n  async getUsage(): Promise<UsageStats | null> {\n    await this.consume();\n    \n    const resultMsg = this.messages.findLast((msg): msg is ResultMessage => msg.type === 'result');\n    if (!resultMsg?.usage) return null;\n    \n    return {\n      inputTokens: resultMsg.usage.input_tokens ?? 0,\n      outputTokens: resultMsg.usage.output_tokens ?? 0,\n      cacheCreationTokens: resultMsg.usage.cache_creation_input_tokens ?? 0,\n      cacheReadTokens: resultMsg.usage.cache_read_input_tokens ?? 0,\n      totalTokens: (resultMsg.usage.input_tokens ?? 0) + (resultMsg.usage.output_tokens ?? 0),\n      totalCost: resultMsg.cost?.total_cost ?? 0\n    };\n  }\n\n  /**\n   * Get the session ID if available\n   */\n  async getSessionId(): Promise<string | null> {\n    await this.consume();\n\n    // Look for session_id on any message (CLI sets this on all messages)\n    for (const msg of this.messages) {\n      if ('session_id' in msg && msg.session_id) {\n        return msg.session_id;\n      }\n\n      // Also check system messages with session data\n      if (msg.type === 'system' && msg.data && typeof msg.data === 'object' && 'session_id' in msg.data) {\n        return String(msg.data.session_id);\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Stream messages with a callback (doesn't consume for other methods)\n   */\n  async stream(callback: (message: Message) => void | Promise<void>): Promise<void> {\n    for await (const message of this.generator) {\n      // Run handlers\n      for (const handler of this.handlers) {\n        try {\n          handler(message);\n        } catch (error) {\n          this.logger?.error('Message handler error', { error });\n        }\n      }\n      \n      // Store message\n      this.messages.push(message);\n      \n      // Run callback\n      await callback(message);\n    }\n    \n    this.consumed = true;\n  }\n\n  /**\n   * Wait for completion and return success status\n   */\n  async succeeded(): Promise<boolean> {\n    await this.consume();\n    \n    const resultMsg = this.messages.findLast((msg): msg is ResultMessage => msg.type === 'result');\n    if (!resultMsg) return false;\n    \n    // Check if any tool execution failed\n    const executions = await this.asToolExecutions();\n    const hasErrors = executions.some(exec => exec.isError);\n    \n    return !hasErrors;\n  }\n\n  /**\n   * Get all error messages\n   */\n  async getErrors(): Promise<string[]> {\n    await this.consume();\n    \n    const errors: string[] = [];\n    \n    // Check system messages for errors\n    for (const msg of this.messages) {\n      if (msg.type === 'system' && msg.subtype === 'error') {\n        const errorMessage = msg.data && typeof msg.data === 'object' && 'message' in msg.data\n          ? String(msg.data.message)\n          : 'Unknown error';\n        errors.push(errorMessage);\n      }\n    }\n    \n    // Check tool results for errors\n    const executions = await this.asToolExecutions();\n    for (const exec of executions) {\n      if (exec.isError) {\n        errors.push(`Tool ${exec.tool} failed: ${exec.result}`);\n      }\n    }\n    \n    return errors;\n  }\n\n  /**\n   * Transform messages using a custom transformer\n   */\n  async transform<T>(transformer: (messages: Message[]) => T): Promise<T> {\n    await this.consume();\n    return transformer(this.messages);\n  }\n\n  /**\n   * Consume the generator if not already consumed\n   */\n  private async consume(): Promise<void> {\n    if (this.consumed) return;\n    \n    this.logger?.debug('Consuming message generator');\n    \n    for await (const message of this.generator) {\n      this.logger?.debug('Received message', { type: message.type });\n      \n      // Run handlers\n      for (const handler of this.handlers) {\n        try {\n          handler(message);\n        } catch (error) {\n          this.logger?.error('Message handler error', { error });\n        }\n      }\n      \n      this.messages.push(message);\n    }\n    \n    this.consumed = true;\n    this.logger?.debug('Message generator consumed', { messageCount: this.messages.length });\n  }\n}\n\n/**\n * Represents a tool execution with its input and result\n */\nexport interface ToolExecution {\n  tool: string;\n  input: Record<string, unknown>;\n  result: unknown;\n  isError: boolean;\n}\n\n/**\n * Usage statistics for a query\n */\nexport interface UsageStats {\n  inputTokens: number;\n  outputTokens: number;\n  cacheCreationTokens: number;\n  cacheReadTokens: number;\n  totalTokens: number;\n  totalCost: number;\n}","import type { \n  MCPServerPermission, \n  MCPServerPermissionConfig,\n  ToolPermission\n} from '../types/permissions.js';\nimport type { ClaudeCodeOptions } from '../types.js';\n\n/**\n * Manages MCP server-level permissions\n */\nexport class PermissionManager {\n  private mcpServerPermissions: Map<string, MCPServerPermission>;\n\n  constructor() {\n    this.mcpServerPermissions = new Map();\n  }\n\n  /**\n   * Set permission for an MCP server\n   */\n  setMCPServerPermission(serverName: string, permission: MCPServerPermission): void {\n    if (!serverName) {\n      throw new Error('Server name cannot be empty');\n    }\n\n    if (!['whitelist', 'blacklist', 'ask'].includes(permission)) {\n      throw new Error(`Invalid permission value: ${permission}`);\n    }\n\n    this.mcpServerPermissions.set(serverName, permission);\n  }\n\n  /**\n   * Get permission for an MCP server\n   */\n  getMCPServerPermission(serverName: string): MCPServerPermission | undefined {\n    return this.mcpServerPermissions.get(serverName);\n  }\n\n  /**\n   * Set multiple MCP server permissions at once\n   */\n  setMCPServerPermissions(permissions: MCPServerPermissionConfig): void {\n    Object.entries(permissions).forEach(([serverName, permission]) => {\n      this.setMCPServerPermission(serverName, permission);\n    });\n  }\n\n  /**\n   * Clear all MCP server permissions\n   */\n  clearMCPServerPermissions(): void {\n    this.mcpServerPermissions.clear();\n  }\n\n  /**\n   * Export current configuration\n   */\n  exportConfig(): MCPServerPermissionConfig {\n    const config: MCPServerPermissionConfig = {};\n    this.mcpServerPermissions.forEach((permission, serverName) => {\n      config[serverName] = permission;\n    });\n    return config;\n  }\n\n  /**\n   * Resolve tool permission based on MCP server permission\n   * Maps MCP server permissions to tool-level permissions\n   */\n  resolveToolPermission(toolName: string, serverName: string): ToolPermission | undefined {\n    const serverPermission = this.getMCPServerPermission(serverName);\n    \n    if (!serverPermission) {\n      return undefined;\n    }\n\n    // Map MCP server permissions to tool permissions\n    const permissionMap: Record<MCPServerPermission, ToolPermission> = {\n      'whitelist': 'allow',\n      'blacklist': 'deny',\n      'ask': 'ask'\n    };\n\n    return permissionMap[serverPermission];\n  }\n\n  /**\n   * Apply permissions to ClaudeCodeOptions\n   */\n  applyToOptions(options: ClaudeCodeOptions, merge: boolean = true): ClaudeCodeOptions {\n    const exportedConfig = this.exportConfig();\n    \n    if (Object.keys(exportedConfig).length === 0) {\n      return options;\n    }\n\n    if (merge && options.mcpServerPermissions) {\n      return {\n        ...options,\n        mcpServerPermissions: {\n          ...options.mcpServerPermissions,\n          ...exportedConfig\n        }\n      };\n    }\n\n    return {\n      ...options,\n      mcpServerPermissions: exportedConfig\n    };\n  }\n\n  /**\n   * Serialize to JSON string\n   */\n  toJSON(): string {\n    return JSON.stringify(this.exportConfig());\n  }\n\n  /**\n   * Deserialize from JSON string\n   */\n  fromJSON(json: string): void {\n    try {\n      const config = JSON.parse(json) as MCPServerPermissionConfig;\n      this.clearMCPServerPermissions();\n      this.setMCPServerPermissions(config);\n    } catch (error) {\n      throw new Error('Invalid JSON');\n    }\n  }\n\n  /**\n   * Clone the permission manager\n   */\n  clone(): PermissionManager {\n    const cloned = new PermissionManager();\n    cloned.setMCPServerPermissions(this.exportConfig());\n    return cloned;\n  }\n\n  /**\n   * Check if a server has any permission set\n   */\n  hasPermission(serverName: string): boolean {\n    return this.mcpServerPermissions.has(serverName);\n  }\n\n  /**\n   * Get all server names with permissions\n   */\n  getServerNames(): string[] {\n    return Array.from(this.mcpServerPermissions.keys());\n  }\n\n  /**\n   * Get count of permissions\n   */\n  get size(): number {\n    return this.mcpServerPermissions.size;\n  }\n\n  /**\n   * Check if empty\n   */\n  get isEmpty(): boolean {\n    return this.mcpServerPermissions.size === 0;\n  }\n}","import { promises as fs } from 'node:fs';\nimport path from 'node:path';\nimport type { \n  MCPConfigSchema, \n  ConfigLoadOptions,\n  ToolPermission,\n  MCPServerConfig,\n  ConfigFormat\n} from '../types/config.js';\nimport type { ClaudeCodeOptions } from '../types.js';\nimport type { MCPServerPermission } from '../types/permissions.js';\nimport { ConfigValidationError } from '../errors.js';\n\n/**\n * Loads and validates configuration files\n */\nexport class ConfigLoader {\n  private loadedConfigs: Map<string, MCPConfigSchema> = new Map();\n\n  /**\n   * Detect file format based on extension\n   */\n  private detectFormat(filePath: string): ConfigFormat {\n    const ext = path.extname(filePath).toLowerCase();\n    if (ext === '.yaml' || ext === '.yml') return 'yaml';\n    return 'json';\n  }\n\n  /**\n   * Load configuration from file\n   */\n  async loadFromFile(filePath: string, options?: ConfigLoadOptions): Promise<MCPConfigSchema> {\n    const absolutePath = path.resolve(filePath);\n    \n    try {\n      await fs.access(absolutePath);\n    } catch (error) {\n      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n        throw new Error(`Failed to read configuration file: ${filePath}`);\n      }\n      throw error;\n    }\n\n    // Check for circular inheritance\n    if (this.loadedConfigs.has(absolutePath)) {\n      const cached = this.loadedConfigs.get(absolutePath)!;\n      // If it's a placeholder (empty object), we have circular inheritance\n      if (Object.keys(cached).length === 0) {\n        throw new Error('Circular inheritance detected');\n      }\n      return cached;\n    }\n\n    // Add placeholder to detect circular references\n    this.loadedConfigs.set(absolutePath, {} as MCPConfigSchema);\n\n    try {\n      const content = await fs.readFile(absolutePath, 'utf-8');\n      const format = options?.format || this.detectFormat(filePath);\n      \n      let config: unknown;\n      if (format === 'yaml') {\n        config = await this.parseYAML(content, options);\n      } else {\n        config = this.parseJSON(content, filePath);\n      }\n      \n      // Handle inheritance if extends field is present\n      if (config && config.extends) {\n        const baseConfigPath = path.resolve(path.dirname(absolutePath), config.extends);\n        const baseConfig = await this.loadFromFile(baseConfigPath, options);\n        delete config.extends; // Remove extends field after processing\n        const merged = this.mergeConfigs(baseConfig, config);\n        this.loadedConfigs.set(absolutePath, merged);\n        return merged;\n      }\n      \n      this.validateConfig(config);\n      this.loadedConfigs.set(absolutePath, config);\n      return config;\n    } catch (error) {\n      // Clean up on error\n      this.loadedConfigs.delete(absolutePath);\n      \n      throw error;\n    }\n  }\n\n  /**\n   * Parse JSON content\n   */\n  private parseJSON(content: string, filePath: string): unknown {\n    try {\n      return JSON.parse(content);\n    } catch (error) {\n      if (error instanceof SyntaxError) {\n        throw new Error(`Invalid JSON in configuration file: ${filePath}`);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Parse YAML content\n   */\n  private async parseYAML(content: string, options?: ConfigLoadOptions): Promise<unknown> {\n    try {\n      // Dynamically import js-yaml to avoid loading it when not needed\n      const yaml = await import('js-yaml');\n      return yaml.load(content, {\n        strict: options?.strict ?? true,\n        schema: yaml.JSON_SCHEMA\n      });\n    } catch (error) {\n      throw new ConfigValidationError(`Invalid YAML: ${(error as Error).message}`);\n    }\n  }\n\n  /**\n   * Validate configuration against schema\n   */\n  validateConfig(config: unknown): MCPConfigSchema {\n    if (!config || typeof config !== 'object') {\n      throw new Error('Configuration must be an object');\n    }\n    const cfg = config as Record<string, unknown>;\n    if (!cfg.version) {\n      throw new Error('Configuration must have a version field');\n    }\n\n    if (cfg.version !== '1.0') {\n      throw new Error(`Unsupported configuration version: ${cfg.version}`);\n    }\n\n    // Validate MCP servers\n    if (cfg.mcpServers) {\n      Object.entries(cfg.mcpServers as Record<string, unknown>).forEach(([serverName, serverConfig]) => {\n        this.validateMCPServerConfig(serverName, serverConfig as MCPServerConfig);\n      });\n    }\n\n    // Validate global settings\n    if (cfg.globalSettings) {\n      this.validateGlobalSettings(cfg.globalSettings);\n    }\n\n    // Validate tools\n    if (cfg.tools) {\n      this.validateTools(cfg.tools);\n    }\n\n    return cfg as MCPConfigSchema;\n  }\n\n  /**\n   * Validate MCP server configuration\n   */\n  private validateMCPServerConfig(serverName: string, config: MCPServerConfig): void {\n    const validPermissions: ToolPermission[] = ['allow', 'deny', 'ask'];\n    \n    if (!validPermissions.includes(config.defaultPermission)) {\n      throw new Error(\n        `Invalid permission value '${config.defaultPermission}' at mcpServers.${serverName}.defaultPermission`\n      );\n    }\n\n    if (config.tools) {\n      Object.entries(config.tools).forEach(([toolName, permission]) => {\n        // Handle complex tool configs that might have nested structure\n        const permValue = typeof permission === 'object' && permission !== null ? permission.permission : permission;\n        if (permValue && !validPermissions.includes(permValue)) {\n          throw new Error(\n            `Invalid permission value '${permValue}' at mcpServers.${serverName}.tools.${toolName}`\n          );\n        }\n      });\n    }\n  }\n\n  /**\n   * Validate global settings\n   */\n  private validateGlobalSettings(settings: unknown): void {\n    if (!settings || typeof settings !== 'object') {\n      throw new Error('Global settings must be an object');\n    }\n    const gs = settings as Record<string, unknown>;\n    if (gs.defaultToolPermission) {\n      const validPermissions: ToolPermission[] = ['allow', 'deny', 'ask'];\n      if (!validPermissions.includes(gs.defaultToolPermission as ToolPermission)) {\n        throw new Error(`Invalid defaultToolPermission: ${gs.defaultToolPermission}`);\n      }\n    }\n\n    if (gs.permissionMode) {\n      const validModes = ['default', 'acceptEdits', 'bypassPermissions', 'ask'];\n      if (!validModes.includes(gs.permissionMode as string)) {\n        throw new Error(`Invalid permissionMode: ${gs.permissionMode}`);\n      }\n    }\n\n    if (gs.timeout && (typeof gs.timeout !== 'number' || gs.timeout <= 0)) {\n      throw new Error('Timeout must be a positive number');\n    }\n\n    if (gs.temperature !== undefined) {\n      if (typeof gs.temperature !== 'number' || gs.temperature < 0 || gs.temperature > 1) {\n        throw new Error('Temperature must be between 0 and 1');\n      }\n    }\n\n    if (gs.maxTokens !== undefined) {\n      // Handle string numbers that YAML might produce\n      const maxTokens = typeof gs.maxTokens === 'string' ? parseInt(gs.maxTokens as string, 10) : gs.maxTokens;\n      if (typeof maxTokens !== 'number' || isNaN(maxTokens) || maxTokens <= 0) {\n        throw new Error('maxTokens must be a positive number');\n      }\n    }\n  }\n\n  /**\n   * Validate tools configuration\n   */\n  private validateTools(tools: unknown): void {\n    if (!tools || typeof tools !== 'object') {\n      throw new Error('Tools configuration must be an object');\n    }\n    const toolsConfig = tools as Record<string, unknown>;\n    if (toolsConfig.allowed && !Array.isArray(toolsConfig.allowed)) {\n      throw new Error('tools.allowed must be an array');\n    }\n\n    if (toolsConfig.denied && !Array.isArray(toolsConfig.denied)) {\n      throw new Error('tools.denied must be an array');\n    }\n  }\n\n  /**\n   * Merge configuration with options\n   */\n  mergeWithOptions(\n    config: MCPConfigSchema, \n    options: ClaudeCodeOptions,\n    mergeOptions?: { configPrecedence?: boolean }\n  ): ClaudeCodeOptions {\n    const merged = { ...options };\n    const configPrecedence = mergeOptions?.configPrecedence ?? true;\n\n    // Apply global settings\n    if (config.globalSettings) {\n      const gs = config.globalSettings;\n      \n      if (configPrecedence) {\n        // Config takes precedence\n        if (gs.model !== undefined) merged.model = gs.model;\n        if (gs.timeout !== undefined) merged.timeout = gs.timeout;\n        if (gs.cwd !== undefined) merged.cwd = gs.cwd;\n        if (gs.permissionMode !== undefined) merged.permissionMode = gs.permissionMode;\n        if (gs.env !== undefined) merged.env = { ...merged.env, ...gs.env };\n        if (gs.temperature !== undefined) merged.temperature = gs.temperature;\n        if (gs.maxTokens !== undefined) merged.maxTokens = gs.maxTokens;\n      } else {\n        // Options take precedence\n        merged.model = merged.model ?? gs.model;\n        merged.timeout = merged.timeout ?? gs.timeout;\n        merged.cwd = merged.cwd ?? gs.cwd;\n        merged.permissionMode = merged.permissionMode ?? gs.permissionMode;\n        merged.env = { ...gs.env, ...merged.env };\n        merged.temperature = merged.temperature ?? gs.temperature;\n        merged.maxTokens = merged.maxTokens ?? gs.maxTokens;\n      }\n    }\n\n    // Apply MCP server permissions\n    if (config.mcpServers) {\n      const mcpServerPermissions: Record<string, MCPServerPermission> = {};\n      \n      Object.entries(config.mcpServers).forEach(([serverName, serverConfig]) => {\n        // Map tool permissions to MCP server permissions\n        const permissionMap: Record<ToolPermission, MCPServerPermission> = {\n          'allow': 'whitelist',\n          'deny': 'blacklist',\n          'ask': 'ask'\n        };\n        \n        mcpServerPermissions[serverName] = permissionMap[serverConfig.defaultPermission];\n      });\n      \n      merged.mcpServerPermissions = {\n        ...merged.mcpServerPermissions,\n        ...mcpServerPermissions\n      };\n    }\n\n    // Apply tool permissions\n    if (config.tools) {\n      if (config.tools.allowed) {\n        merged.allowedTools = [\n          ...config.tools.allowed,\n          ...(merged.allowedTools || [])\n        ];\n      }\n      \n      if (config.tools.denied) {\n        merged.deniedTools = [\n          ...config.tools.denied,\n          ...(merged.deniedTools || [])\n        ];\n      }\n    }\n\n    return merged;\n  }\n\n  /**\n   * Expand environment variables in configuration\n   */\n  expandEnvironmentVariables(config: MCPConfigSchema): MCPConfigSchema {\n    const expanded = JSON.parse(JSON.stringify(config)); // Deep clone\n    \n    const expandValue = (value: unknown): unknown => {\n      if (typeof value === 'string') {\n        return value.replace(/\\$\\{([^}]+)\\}/g, (match, varName) => {\n          const envValue = process.env[varName];\n          if (envValue === undefined) {\n            throw new Error(`Environment variable ${varName} not found`);\n          }\n          return envValue;\n        });\n      } else if (typeof value === 'object' && value !== null) {\n        Object.keys(value).forEach(key => {\n          value[key] = expandValue(value[key]);\n        });\n      }\n      return value;\n    };\n    \n    return expandValue(expanded);\n  }\n\n  /**\n   * Merge two configurations\n   */\n  private mergeConfigs(base: MCPConfigSchema, override: MCPConfigSchema): MCPConfigSchema {\n    const merged: MCPConfigSchema = {\n      version: override.version || base.version\n    };\n\n    // Merge global settings\n    if (base.globalSettings || override.globalSettings) {\n      merged.globalSettings = {\n        ...base.globalSettings,\n        ...override.globalSettings\n      };\n    }\n\n    // Merge MCP servers\n    if (base.mcpServers || override.mcpServers) {\n      merged.mcpServers = {\n        ...base.mcpServers,\n        ...override.mcpServers\n      };\n    }\n\n    // Merge tools\n    if (base.tools || override.tools) {\n      merged.tools = {\n        allowed: [\n          ...(base.tools?.allowed || []),\n          ...(override.tools?.allowed || [])\n        ],\n        denied: [\n          ...(base.tools?.denied || []),\n          ...(override.tools?.denied || [])\n        ]\n      };\n    }\n\n    return merged;\n  }\n\n  /**\n   * Clear loaded configurations cache\n   */\n  clearCache(): void {\n    this.loadedConfigs.clear();\n  }\n\n  /**\n   * Get a cached configuration\n   */\n  getCached(filePath: string): MCPConfigSchema | undefined {\n    return this.loadedConfigs.get(filePath);\n  }\n}","import { promises as fs } from 'node:fs';\nimport path from 'node:path';\nimport type { \n  RoleDefinition, \n  RolesConfig, \n  RoleValidationResult,\n  RoleApplicationOptions,\n  RoleInheritanceChain\n} from '../types/roles.js';\nimport type { ClaudeCodeOptions } from '../types.js';\nimport type { ConfigFormat, ConfigLoadOptions } from '../types/config.js';\nimport { ConfigValidationError } from '../errors.js';\n\n/**\n * Manages role definitions and applications\n */\nexport class RoleManager {\n  private roles: Map<string, RoleDefinition> = new Map();\n  private defaultRole: string | undefined;\n\n  /**\n   * Add a role definition\n   */\n  addRole(role: RoleDefinition): RoleManager {\n    const validation = this.validateRole(role);\n    if (!validation.valid) {\n      throw new Error(`Invalid role definition: ${validation.errors?.join(', ')}`);\n    }\n    \n    this.roles.set(role.name, role);\n    return this;\n  }\n\n  /**\n   * Get a role by name\n   */\n  getRole(name: string): RoleDefinition | undefined {\n    return this.roles.get(name);\n  }\n\n  /**\n   * Check if a role exists\n   */\n  hasRole(name: string): boolean {\n    return this.roles.has(name);\n  }\n\n  /**\n   * List all role names\n   */\n  listRoles(): string[] {\n    return Array.from(this.roles.keys());\n  }\n\n  /**\n   * Set the default role\n   */\n  setDefaultRole(name: string): RoleManager {\n    if (!this.roles.has(name)) {\n      throw new Error(`Role '${name}' not found`);\n    }\n    this.defaultRole = name;\n    return this;\n  }\n\n  /**\n   * Get the default role\n   */\n  getDefaultRole(): string | undefined {\n    return this.defaultRole;\n  }\n\n  /**\n   * Detect file format based on extension\n   */\n  private detectFormat(filePath: string): ConfigFormat {\n    const ext = path.extname(filePath).toLowerCase();\n    if (ext === '.yaml' || ext === '.yml') return 'yaml';\n    return 'json';\n  }\n\n  /**\n   * Parse JSON content\n   */\n  private parseJSON(content: string, filePath: string): unknown {\n    try {\n      return JSON.parse(content);\n    } catch (error) {\n      if (error instanceof SyntaxError) {\n        throw new Error(`Invalid JSON in roles file: ${filePath}`);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Parse YAML content\n   */\n  private async parseYAML(content: string, options?: ConfigLoadOptions): Promise<unknown> {\n    try {\n      const yaml = await import('js-yaml');\n      return yaml.load(content, {\n        strict: options?.strict ?? true,\n        schema: yaml.JSON_SCHEMA\n      });\n    } catch (error) {\n      throw new ConfigValidationError(`Invalid YAML: ${(error as Error).message}`);\n    }\n  }\n\n  /**\n   * Load roles from a configuration file\n   */\n  async loadFromFile(filePath: string, options?: ConfigLoadOptions): Promise<void> {\n    try {\n      await fs.access(filePath);\n    } catch (error) {\n      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n        throw new Error(`Failed to read roles file: ${filePath}`);\n      }\n      throw error;\n    }\n\n    const content = await fs.readFile(filePath, 'utf-8');\n    const format = options?.format || this.detectFormat(filePath);\n    \n    let config: RolesConfig;\n    if (format === 'yaml') {\n      config = await this.parseYAML(content, options);\n    } else {\n      config = this.parseJSON(content, filePath);\n    }\n    \n    this.loadFromConfig(config);\n  }\n\n  /**\n   * Load roles from configuration object\n   */\n  loadFromConfig(config: RolesConfig): void {\n    if (config.version !== '1.0') {\n      throw new Error(`Unsupported roles configuration version: ${config.version}`);\n    }\n\n    // Clear existing roles\n    this.roles.clear();\n\n    // Add all roles\n    Object.entries(config.roles).forEach(([name, roleConfig]) => {\n      const role: RoleDefinition = {\n        name,\n        ...roleConfig\n      };\n      this.addRole(role);\n    });\n\n    // Set default role if specified\n    if (config.defaultRole) {\n      this.setDefaultRole(config.defaultRole);\n    }\n  }\n\n  /**\n   * Apply a role to options\n   */\n  applyRole(\n    roleName: string, \n    options: ClaudeCodeOptions,\n    applicationOptions?: RoleApplicationOptions\n  ): ClaudeCodeOptions {\n    const role = this.getRole(roleName);\n    if (!role) {\n      throw new Error(`Role '${roleName}' not found`);\n    }\n\n    // Resolve inheritance\n    const resolvedRole = this.resolveInheritance(role);\n    \n    return this.applyRoleToOptions(resolvedRole, options, applicationOptions);\n  }\n\n  /**\n   * Resolve role inheritance\n   */\n  resolveInheritance(role: RoleDefinition): RoleDefinition {\n    const chain = this.getInheritanceChain(role);\n    \n    if (chain.hasCircularDependency) {\n      throw new Error('Circular inheritance detected');\n    }\n\n    // Start with empty role\n    let resolved: RoleDefinition = {\n      name: role.name,\n      model: role.model,\n      permissions: {}\n    };\n\n    // Apply inheritance from parent to child\n    for (let i = chain.chain.length - 1; i >= 0; i--) {\n      const currentRole = this.getRole(chain.chain[i]);\n      if (!currentRole) continue;\n      \n      resolved = this.mergeRoles(resolved, currentRole);\n    }\n\n    return resolved;\n  }\n\n  /**\n   * Get inheritance chain for a role\n   */\n  private getInheritanceChain(role: RoleDefinition, visited: Set<string> = new Set()): RoleInheritanceChain {\n    const chain: string[] = [role.name];\n    \n    if (visited.has(role.name)) {\n      return { chain, hasCircularDependency: true };\n    }\n    \n    visited.add(role.name);\n    \n    if (role.extends) {\n      const parent = this.getRole(role.extends);\n      if (!parent) {\n        throw new Error(`Parent role '${role.extends}' not found`);\n      }\n      \n      const parentChain = this.getInheritanceChain(parent, visited);\n      chain.push(...parentChain.chain);\n      \n      if (parentChain.hasCircularDependency) {\n        return { chain, hasCircularDependency: true };\n      }\n    }\n    \n    return { chain, hasCircularDependency: false };\n  }\n\n  /**\n   * Merge two roles (child overrides parent)\n   */\n  private mergeRoles(parent: RoleDefinition, child: RoleDefinition): RoleDefinition {\n    const merged: RoleDefinition = {\n      name: child.name,\n      model: child.model || parent.model,\n      permissions: {\n        ...(parent.permissions || {}),\n        mode: child.permissions?.mode || parent.permissions?.mode,\n        mcpServers: {\n          ...(parent.permissions?.mcpServers || {}),\n          ...(child.permissions?.mcpServers || {})\n        },\n        tools: {\n          allowed: [\n            ...(parent.permissions?.tools?.allowed || []),\n            ...(child.permissions?.tools?.allowed || [])\n          ],\n          denied: [\n            ...(parent.permissions?.tools?.denied || []),\n            ...(child.permissions?.tools?.denied || [])\n          ]\n        }\n      }\n    };\n\n    // Merge optional fields\n    if (parent.description || child.description) {\n      merged.description = child.description || parent.description;\n    }\n\n    if (parent.promptingTemplate || child.promptingTemplate) {\n      merged.promptingTemplate = child.promptingTemplate || parent.promptingTemplate;\n    }\n\n    if (parent.systemPrompt || child.systemPrompt) {\n      merged.systemPrompt = child.systemPrompt || parent.systemPrompt;\n    }\n\n    // Merge context\n    if (parent.context || child.context) {\n      merged.context = {\n        ...parent.context,\n        ...child.context\n      };\n    }\n\n    // Merge metadata\n    if (parent.metadata || child.metadata) {\n      merged.metadata = {\n        ...parent.metadata,\n        ...child.metadata\n      };\n    }\n\n    return merged;\n  }\n\n  /**\n   * Apply role definition to options\n   */\n  private applyRoleToOptions(\n    role: RoleDefinition, \n    options: ClaudeCodeOptions,\n    applicationOptions?: RoleApplicationOptions\n  ): ClaudeCodeOptions {\n    const applied = { ...options };\n    const override = applicationOptions?.override ?? true;\n\n    // Apply model\n    if (override || !applied.model) {\n      applied.model = role.model;\n    }\n\n    // Apply permissions\n    if (role.permissions.mode && (override || !applied.permissionMode)) {\n      applied.permissionMode = role.permissions.mode;\n    }\n\n    // Apply MCP server permissions\n    if (role.permissions.mcpServers && Object.keys(role.permissions.mcpServers).length > 0) {\n      applied.mcpServerPermissions = {\n        ...(applied.mcpServerPermissions || {}),\n        ...role.permissions.mcpServers\n      };\n    }\n\n    // Apply tools\n    if (role.permissions.tools?.allowed) {\n      if (applicationOptions?.mergeArrays) {\n        applied.allowedTools = [\n          ...(applied.allowedTools || []),\n          ...role.permissions.tools.allowed\n        ];\n      } else {\n        applied.allowedTools = role.permissions.tools.allowed;\n      }\n    }\n\n    if (role.permissions.tools?.denied) {\n      if (applicationOptions?.mergeArrays) {\n        applied.deniedTools = [\n          ...(applied.deniedTools || []),\n          ...role.permissions.tools.denied\n        ];\n      } else {\n        applied.deniedTools = role.permissions.tools.denied;\n      }\n    }\n\n    // Apply context\n    if (role.context) {\n      if (role.context.maxTokens && (override || !applied.maxTokens)) {\n        applied.maxTokens = role.context.maxTokens;\n      }\n      if (role.context.temperature !== undefined && (override || applied.temperature === undefined)) {\n        applied.temperature = role.context.temperature;\n      }\n      if (role.context.additionalContext) {\n        applied.context = [\n          ...(applied.context || []),\n          ...role.context.additionalContext\n        ];\n      }\n    }\n\n    // Apply system prompt\n    if (role.systemPrompt && (override || !applied.systemPrompt)) {\n      applied.systemPrompt = role.systemPrompt;\n    }\n\n    return applied;\n  }\n\n  /**\n   * Validate a role definition\n   */\n  validateRole(role: RoleDefinition): RoleValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    // Required fields\n    if (!role.name) {\n      errors.push('Role must have a name');\n    }\n\n    if (!role.model) {\n      errors.push('Role \"' + role.name + '\" must have a model');\n    } else {\n      const validModels = ['opus', 'sonnet', 'haiku', 'claude-3-opus', 'claude-3-sonnet', 'claude-3-haiku'];\n      if (!validModels.some(m => role.model.includes(m))) {\n        errors.push(`Invalid model '${role.model}'`);\n      }\n    }\n\n    // Validate permissions\n    if (role.permissions?.mode) {\n      const validModes = ['default', 'acceptEdits', 'bypassPermissions'];\n      if (!validModes.includes(role.permissions.mode)) {\n        errors.push('Invalid permission mode');\n      }\n      \n      if (role.permissions.mode === 'bypassPermissions') {\n        warnings.push('bypassPermissions mode may pose security risks');\n      }\n    }\n\n    // Validate context\n    if (role.context) {\n      if (role.context.temperature !== undefined) {\n        if (role.context.temperature < 0 || role.context.temperature > 1) {\n          errors.push('Temperature must be between 0 and 1');\n        } else if (role.context.temperature > 0.9) {\n          warnings.push(`High temperature (${role.context.temperature}) may produce inconsistent results`);\n        }\n      }\n      \n      if (role.context.maxTokens !== undefined && role.context.maxTokens <= 0) {\n        errors.push('Max tokens must be positive');\n      }\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors: errors.length > 0 ? errors : undefined,\n      warnings: warnings.length > 0 ? warnings : undefined\n    };\n  }\n\n  /**\n   * Get prompting template with variable interpolation\n   */\n  getPromptingTemplate(roleName: string, variables: Record<string, string>): string {\n    const role = this.getRole(roleName);\n    if (!role || !role.promptingTemplate) {\n      throw new Error(`No prompting template found for role '${roleName}'`);\n    }\n\n    return this.interpolateTemplate(role.promptingTemplate, variables);\n  }\n\n  /**\n   * Get full prompt including system prompt and template\n   */\n  getFullPrompt(\n    roleName: string, \n    variables: Record<string, string>, \n    userPrompt: string\n  ): string {\n    const role = this.getRole(roleName);\n    if (!role) {\n      throw new Error(`Role '${roleName}' not found`);\n    }\n\n    const parts: string[] = [];\n    \n    if (role.systemPrompt) {\n      parts.push(role.systemPrompt);\n    }\n    \n    if (role.promptingTemplate) {\n      parts.push(this.interpolateTemplate(role.promptingTemplate, variables));\n    }\n    \n    parts.push(userPrompt);\n    \n    return parts.join('\\n\\n');\n  }\n\n  /**\n   * Interpolate template variables\n   */\n  private interpolateTemplate(template: string, variables: Record<string, string>): string {\n    return template.replace(/\\$\\{([^}]+)\\}/g, (match, varName) => {\n      if (!(varName in variables)) {\n        throw new Error(`Missing template variable: ${varName}`);\n      }\n      return variables[varName];\n    });\n  }\n\n  /**\n   * Export configuration\n   */\n  exportConfig(): RolesConfig {\n    const config: RolesConfig = {\n      version: '1.0',\n      roles: {}\n    };\n\n    this.roles.forEach((role, name) => {\n      const { name: _, ...roleConfig } = role;\n      config.roles[name] = roleConfig;\n    });\n\n    if (this.defaultRole) {\n      config.defaultRole = this.defaultRole;\n    }\n\n    return config;\n  }\n\n  /**\n   * Clear all roles\n   */\n  clear(): void {\n    this.roles.clear();\n    this.defaultRole = undefined;\n  }\n\n  /**\n   * Get count of roles\n   */\n  get size(): number {\n    return this.roles.size;\n  }\n}","/**\n * Log levels for the logging framework\n */\nexport enum LogLevel {\n  ERROR = 0,\n  WARN = 1,\n  INFO = 2,\n  DEBUG = 3,\n  TRACE = 4\n}\n\n/**\n * Log entry structure\n */\nexport interface LogEntry {\n  level: LogLevel;\n  message: string;\n  timestamp: Date;\n  context?: Record<string, unknown>;\n  error?: Error;\n}\n\n/**\n * Logger interface for pluggable logging\n * \n * @example\n * ```typescript\n * class CustomLogger implements Logger {\n *   log(entry: LogEntry): void {\n *     // Send to your logging service\n *   }\n * }\n * \n * const result = await claude()\n *   .withLogger(new CustomLogger())\n *   .query('Hello');\n * ```\n */\nexport interface Logger {\n  /**\n   * Log an entry\n   */\n  log(entry: LogEntry): void;\n\n  /**\n   * Convenience methods\n   */\n  error(message: string, context?: Record<string, unknown>): void;\n  warn(message: string, context?: Record<string, unknown>): void;\n  info(message: string, context?: Record<string, unknown>): void;\n  debug(message: string, context?: Record<string, unknown>): void;\n  trace(message: string, context?: Record<string, unknown>): void;\n}\n\n/**\n * Console logger implementation\n */\nexport class ConsoleLogger implements Logger {\n  constructor(\n    private minLevel: LogLevel = LogLevel.INFO,\n    private prefix: string = '[Claude SDK]'\n  ) {}\n\n  log(entry: LogEntry): void {\n    if (entry.level > this.minLevel) return;\n\n    const timestamp = entry.timestamp.toISOString();\n    const level = LogLevel[entry.level];\n    const prefix = `${timestamp} ${this.prefix} ${level}`;\n    \n    const args: unknown[] = [`${prefix}: ${entry.message}`];\n    \n    if (entry.context && Object.keys(entry.context).length > 0) {\n      // Serialize nested objects properly\n      args.push(JSON.stringify(entry.context, null, 2));\n    }\n    \n    if (entry.error) {\n      args.push(entry.error);\n    }\n\n    switch (entry.level) {\n      case LogLevel.ERROR:\n        console.error(...args);\n        break;\n      case LogLevel.WARN:\n        console.warn(...args);\n        break;\n      case LogLevel.INFO:\n        console.info(...args);\n        break;\n      case LogLevel.DEBUG:\n      case LogLevel.TRACE:\n        console.log(...args);\n        break;\n    }\n  }\n\n  error(message: string, context?: Record<string, unknown>): void {\n    this.log({\n      level: LogLevel.ERROR,\n      message,\n      timestamp: new Date(),\n      context,\n      error: context?.error instanceof Error ? context.error : undefined\n    });\n  }\n\n  warn(message: string, context?: Record<string, unknown>): void {\n    this.log({\n      level: LogLevel.WARN,\n      message,\n      timestamp: new Date(),\n      context\n    });\n  }\n\n  info(message: string, context?: Record<string, unknown>): void {\n    this.log({\n      level: LogLevel.INFO,\n      message,\n      timestamp: new Date(),\n      context\n    });\n  }\n\n  debug(message: string, context?: Record<string, unknown>): void {\n    this.log({\n      level: LogLevel.DEBUG,\n      message,\n      timestamp: new Date(),\n      context\n    });\n  }\n\n  trace(message: string, context?: Record<string, unknown>): void {\n    this.log({\n      level: LogLevel.TRACE,\n      message,\n      timestamp: new Date(),\n      context\n    });\n  }\n}\n\n/**\n * Structured logger that outputs JSON\n */\nexport class JSONLogger implements Logger {\n  constructor(\n    private minLevel: LogLevel = LogLevel.INFO,\n    private output: (json: string) => void = console.log\n  ) {}\n\n  log(entry: LogEntry): void {\n    if (entry.level > this.minLevel) return;\n\n    const logObject = {\n      level: LogLevel[entry.level],\n      message: entry.message,\n      timestamp: entry.timestamp.toISOString(),\n      context: entry.context,\n      ...(entry.error && {\n        error: {\n          message: entry.error.message,\n          stack: entry.error.stack,\n          name: entry.error.name\n        }\n      })\n    };\n\n    this.output(JSON.stringify(logObject));\n  }\n\n  error(message: string, context?: Record<string, unknown>): void {\n    this.log({\n      level: LogLevel.ERROR,\n      message,\n      timestamp: new Date(),\n      context,\n      error: context?.error instanceof Error ? context.error : undefined\n    });\n  }\n\n  warn(message: string, context?: Record<string, unknown>): void {\n    this.log({\n      level: LogLevel.WARN,\n      message,\n      timestamp: new Date(),\n      context\n    });\n  }\n\n  info(message: string, context?: Record<string, unknown>): void {\n    this.log({\n      level: LogLevel.INFO,\n      message,\n      timestamp: new Date(),\n      context\n    });\n  }\n\n  debug(message: string, context?: Record<string, unknown>): void {\n    this.log({\n      level: LogLevel.DEBUG,\n      message,\n      timestamp: new Date(),\n      context\n    });\n  }\n\n  trace(message: string, context?: Record<string, unknown>): void {\n    this.log({\n      level: LogLevel.TRACE,\n      message,\n      timestamp: new Date(),\n      context\n    });\n  }\n}\n\n/**\n * Multi-logger that sends logs to multiple loggers\n */\nexport class MultiLogger implements Logger {\n  constructor(private loggers: Logger[]) {}\n\n  log(entry: LogEntry): void {\n    for (const logger of this.loggers) {\n      try {\n        logger.log(entry);\n      } catch {\n        // Continue to next logger\n      }\n    }\n  }\n\n  error(message: string, context?: Record<string, unknown>): void {\n    for (const logger of this.loggers) {\n      try {\n        logger.error(message, context);\n      } catch {\n        // Continue to next logger\n      }\n    }\n  }\n\n  warn(message: string, context?: Record<string, unknown>): void {\n    for (const logger of this.loggers) {\n      try {\n        logger.warn(message, context);\n      } catch {\n        // Continue to next logger\n      }\n    }\n  }\n\n  info(message: string, context?: Record<string, unknown>): void {\n    for (const logger of this.loggers) {\n      try {\n        logger.info(message, context);\n      } catch {\n        // Continue to next logger\n      }\n    }\n  }\n\n  debug(message: string, context?: Record<string, unknown>): void {\n    for (const logger of this.loggers) {\n      try {\n        logger.debug(message, context);\n      } catch {\n        // Continue to next logger\n      }\n    }\n  }\n\n  trace(message: string, context?: Record<string, unknown>): void {\n    for (const logger of this.loggers) {\n      try {\n        logger.trace(message, context);\n      } catch {\n        // Continue to next logger\n      }\n    }\n  }\n}\n\n/**\n * Null logger that discards all logs (useful for testing)\n */\nexport class NullLogger implements Logger {\n  log(_entry: LogEntry): void {\n    // Discard\n  }\n\n  error(_message: string, _context?: Record<string, any>): void {\n    // Discard\n  }\n\n  warn(_message: string, _context?: Record<string, any>): void {\n    // Discard\n  }\n\n  info(_message: string, _context?: Record<string, any>): void {\n    // Discard\n  }\n\n  debug(_message: string, _context?: Record<string, any>): void {\n    // Discard\n  }\n\n  trace(_message: string, _context?: Record<string, any>): void {\n    // Discard\n  }\n}","import { query as baseQuery } from './index.js';\nimport type { \n  ClaudeCodeOptions, \n  Message, \n  ToolName, \n  PermissionMode,\n  MCPServerPermission,\n  MCPServerPermissionConfig,\n  MCPConfigSchema,\n  RoleDefinition,\n  ContentBlock\n} from './types.js';\nimport { ResponseParser } from './parser.js';\nimport { Logger } from './logger.js';\nimport { PermissionManager } from './permissions/manager.js';\nimport { ConfigLoader } from './config/loader.js';\nimport { RoleManager } from './roles/manager.js';\n\n/**\n * Fluent API for building Claude Code queries with chainable methods\n * \n * @example\n * ```typescript\n * const result = await claude()\n *   .withModel('opus')\n *   .allowTools('Read', 'Write')\n *   .skipPermissions()\n *   .withTimeout(30000)\n *   .onMessage(msg => console.log('Got:', msg.type))\n *   .query('Create a README file')\n *   .asText();\n * ```\n */\nexport class QueryBuilder {\n  private options: ClaudeCodeOptions = {};\n  private messageHandlers: Array<(message: Message) => void> = [];\n  private logger?: Logger;\n  private permissionManager: PermissionManager;\n  private configLoader: ConfigLoader;\n  private roleManager: RoleManager;\n  private rolePromptingTemplate?: string;\n  private roleTemplateVariables?: Record<string, string>;\n\n  constructor() {\n    this.permissionManager = new PermissionManager();\n    this.configLoader = new ConfigLoader();\n    this.roleManager = new RoleManager();\n  }\n\n  /**\n   * Set the model to use\n   */\n  withModel(model: string): this {\n    this.options.model = model;\n    return this;\n  }\n\n  /**\n   * Set allowed tools\n   * Use allowTools() with no arguments to enforce read-only mode (denies all tools)\n   */\n  allowTools(...tools: ToolName[]): this {\n    if (tools.length === 0) {\n      // Enforce read-only mode by denying all tools\n      const allTools: ToolName[] = [\n        'Read', 'Write', 'Edit', 'Bash', 'Grep', 'Glob', 'LS',\n        'MultiEdit', 'NotebookRead', 'NotebookEdit', 'WebFetch',\n        'TodoRead', 'TodoWrite', 'WebSearch', 'Task', 'MCPTool'\n      ];\n      this.options.deniedTools = allTools;\n      this.options.allowedTools = [];\n    } else {\n      this.options.allowedTools = tools;\n    }\n    return this;\n  }\n\n  /**\n   * Set denied tools\n   */\n  denyTools(...tools: ToolName[]): this {\n    this.options.deniedTools = tools;\n    return this;\n  }\n\n  /**\n   * Set permission mode\n   */\n  withPermissions(mode: PermissionMode): this {\n    this.options.permissionMode = mode;\n    return this;\n  }\n\n  /**\n   * Skip all permissions (shorthand for bypassPermissions)\n   */\n  skipPermissions(): this {\n    this.options.permissionMode = 'bypassPermissions';\n    return this;\n  }\n\n  /**\n   * Accept all edits automatically\n   */\n  acceptEdits(): this {\n    this.options.permissionMode = 'acceptEdits';\n    return this;\n  }\n\n  /**\n   * Set working directory\n   */\n  inDirectory(cwd: string): this {\n    this.options.cwd = cwd;\n    return this;\n  }\n\n  /**\n   * Set environment variables\n   */\n  withEnv(env: Record<string, string>): this {\n    this.options.env = { ...this.options.env, ...env };\n    return this;\n  }\n\n  /**\n   * Set timeout in milliseconds\n   */\n  withTimeout(ms: number): this {\n    this.options.timeout = ms;\n    return this;\n  }\n\n  /**\n   * Set AbortSignal for cancellation\n   */\n  withSignal(signal: AbortSignal): this {\n    this.options.signal = signal;\n    return this;\n  }\n\n  /**\n   * Set session ID for continuing an existing conversation\n   */\n  withSessionId(sessionId: string): this {\n    this.options.sessionId = sessionId;\n    return this;\n  }\n\n  /**\n   * Enable debug mode\n   */\n  debug(enabled = true): this {\n    this.options.debug = enabled;\n    return this;\n  }\n\n  /**\n   * Add MCP servers\n   */\n  withMCP(...servers: NonNullable<ClaudeCodeOptions['mcpServers']>): this {\n    this.options.mcpServers = [...(this.options.mcpServers || []), ...servers];\n    return this;\n  }\n\n  /**\n   * Add directory(-ies) to include in the context\n   */\n  addDirectory(directories: string | string[]): this {\n    if (!this.options.addDirectories) {\n      this.options.addDirectories = [];\n    }\n    const dirsToAdd = Array.isArray(directories) ? directories : [directories];\n    this.options.addDirectories.push(...dirsToAdd);\n    return this;\n  }\n\n  /**\n   * Set logger\n   */\n  withLogger(logger: Logger): this {\n    this.logger = logger;\n    return this;\n  }\n\n  /**\n   * Add message handler\n   */\n  onMessage(handler: (message: Message) => void): this {\n    this.messageHandlers.push(handler);\n    return this;\n  }\n\n  /**\n   * Add handler for specific message type\n   */\n  onAssistant(handler: (content: ContentBlock[]) => void): this {\n    this.messageHandlers.push((msg) => {\n      if (msg.type === 'assistant') {\n        handler(msg.content);\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Add handler for tool usage\n   */\n  onToolUse(handler: (tool: { name: string; input: Record<string, unknown> }) => void): this {\n    this.messageHandlers.push((msg) => {\n      if (msg.type === 'assistant') {\n        for (const block of msg.content) {\n          if (block.type === 'tool_use') {\n            handler({ name: block.name, input: block.input });\n          }\n        }\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Set MCP server permission\n   */\n  withMCPServerPermission(serverName: string, permission: MCPServerPermission): this {\n    this.permissionManager.setMCPServerPermission(serverName, permission);\n    return this;\n  }\n\n  /**\n   * Set multiple MCP server permissions\n   */\n  withMCPServerPermissions(permissions: MCPServerPermissionConfig): this {\n    this.permissionManager.setMCPServerPermissions(permissions);\n    return this;\n  }\n\n  /**\n   * Load configuration from file\n   */\n  async withConfigFile(filePath: string): Promise<this> {\n    const config = await this.configLoader.loadFromFile(filePath);\n    this.applyConfig(config);\n    return this;\n  }\n\n  /**\n   * Apply configuration object\n   */\n  withConfig(config: MCPConfigSchema): this {\n    this.configLoader.validateConfig(config);\n    this.applyConfig(config);\n    return this;\n  }\n\n  /**\n   * Load roles from file\n   */\n  async withRolesFile(filePath: string): Promise<this> {\n    await this.roleManager.loadFromFile(filePath);\n    return this;\n  }\n\n  /**\n   * Apply a role by name\n   */\n  withRole(roleName: string): this;\n  /**\n   * Apply a role definition directly with template variables\n   */\n  withRole(role: RoleDefinition, templateVariables?: Record<string, string>): this;\n  withRole(\n    roleOrName: string | RoleDefinition, \n    templateVariables?: Record<string, string>\n  ): this {\n    if (typeof roleOrName === 'string') {\n      const options = this.roleManager.applyRole(roleOrName, this.options);\n      this.options = options;\n      \n      // Store role template info if available\n      const role = this.roleManager.getRole(roleOrName);\n      if (role?.promptingTemplate) {\n        this.rolePromptingTemplate = role.promptingTemplate;\n      }\n      if (role?.systemPrompt) {\n        this.options.systemPrompt = role.systemPrompt;\n      }\n    } else {\n      // Add role to manager and apply\n      this.roleManager.addRole(roleOrName);\n      const options = this.roleManager.applyRole(roleOrName.name, this.options);\n      this.options = options;\n      \n      if (roleOrName.promptingTemplate) {\n        this.rolePromptingTemplate = roleOrName.promptingTemplate;\n        this.roleTemplateVariables = templateVariables;\n      }\n      if (roleOrName.systemPrompt) {\n        this.options.systemPrompt = roleOrName.systemPrompt;\n      }\n    }\n    \n    return this;\n  }\n\n  /**\n   * Apply configuration to options\n   */\n  private applyConfig(config: MCPConfigSchema): void {\n    this.options = this.configLoader.mergeWithOptions(config, this.options);\n  }\n\n  /**\n   * Execute query and return response parser\n   */\n  query(prompt: string): ResponseParser {\n    // Apply MCP server permissions\n    const finalOptions = this.permissionManager.applyToOptions(this.options);\n    \n    // Apply prompting template if available\n    let finalPrompt = prompt;\n    if (this.rolePromptingTemplate && this.roleTemplateVariables) {\n      const templatedPrompt = this.rolePromptingTemplate.replace(\n        /\\$\\{([^}]+)\\}/g, \n        (match, varName) => this.roleTemplateVariables![varName] || match\n      );\n      \n      if (finalOptions.systemPrompt) {\n        finalPrompt = `${finalOptions.systemPrompt}\\n\\n${templatedPrompt}\\n\\n${prompt}`;\n      } else {\n        finalPrompt = `${templatedPrompt}\\n\\n${prompt}`;\n      }\n    } else if (finalOptions.systemPrompt) {\n      finalPrompt = `${finalOptions.systemPrompt}\\n\\n${prompt}`;\n    }\n    \n    const parser = new ResponseParser(\n      baseQuery(finalPrompt, finalOptions),\n      this.messageHandlers,\n      this.logger\n    );\n    return parser;\n  }\n\n  /**\n   * Execute query and return raw async generator (for backward compatibility)\n   */\n  async *queryRaw(prompt: string): AsyncGenerator<Message> {\n    // Apply MCP server permissions\n    const finalOptions = this.permissionManager.applyToOptions(this.options);\n    \n    // Apply prompting template if available\n    let finalPrompt = prompt;\n    if (this.rolePromptingTemplate && this.roleTemplateVariables) {\n      const templatedPrompt = this.rolePromptingTemplate.replace(\n        /\\$\\{([^}]+)\\}/g, \n        (match, varName) => this.roleTemplateVariables![varName] || match\n      );\n      \n      if (finalOptions.systemPrompt) {\n        finalPrompt = `${finalOptions.systemPrompt}\\n\\n${templatedPrompt}\\n\\n${prompt}`;\n      } else {\n        finalPrompt = `${templatedPrompt}\\n\\n${prompt}`;\n      }\n    } else if (finalOptions.systemPrompt) {\n      finalPrompt = `${finalOptions.systemPrompt}\\n\\n${prompt}`;\n    }\n    \n    this.logger?.info('Starting query', { prompt: finalPrompt, options: finalOptions });\n    \n    for await (const message of baseQuery(finalPrompt, finalOptions)) {\n      this.logger?.debug('Received message', { type: message.type });\n      \n      // Run handlers\n      for (const handler of this.messageHandlers) {\n        try {\n          handler(message);\n        } catch (error) {\n          this.logger?.error('Message handler error', { error });\n        }\n      }\n      \n      yield message;\n    }\n    \n    this.logger?.info('Query completed');\n  }\n\n  /**\n   * Static factory method for cleaner syntax\n   */\n  static create(): QueryBuilder {\n    return new QueryBuilder();\n  }\n}\n\n/**\n * Factory function for creating a new query builder\n * \n * @example\n * ```typescript\n * const response = await claude()\n *   .withModel('sonnet')\n *   .query('Hello')\n *   .asText();\n * ```\n */\nexport function claude(): QueryBuilder {\n  return new QueryBuilder();\n}\n\n// Re-export for convenience\nexport { ResponseParser } from './parser.js';\nexport { Logger, LogLevel, ConsoleLogger } from './logger.js';","/**\n * Token-level streaming implementation for Claude SDK\n */\n\nimport type {\n  TokenStream,\n  TokenChunk,\n  StreamController,\n  StreamMetrics,\n  StreamState,\n  StreamEvent,\n  StreamEventHandler\n} from '../types/streaming.js';\nimport type { Message, AssistantMessage, TextBlock } from '../types.js';\n\nexport class TokenStreamImpl implements TokenStream {\n  private controller: StreamControllerImpl;\n  private snapshot: TokenChunk[] = [];\n  private metrics: StreamMetrics;\n  private messageGenerator: AsyncGenerator<Message>;\n  private tokenGenerator?: AsyncGenerator<TokenChunk>;\n  private completionPromise: Promise<void>;\n  private completionResolve?: () => void;\n  private completionReject?: (error: Error) => void;\n  private eventHandlers = new Map<StreamEvent, Set<StreamEventHandler>>();\n  private startTime: number;\n  \n  constructor(messageGenerator: AsyncGenerator<Message>) {\n    this.messageGenerator = messageGenerator;\n    this.controller = new StreamControllerImpl();\n    this.startTime = Date.now();\n    this.metrics = {\n      tokensEmitted: 0,\n      duration: 0,\n      state: 'active',\n      averageTokensPerSecond: 0,\n      bytesReceived: 0,\n      lastTokenTime: undefined,\n      pauseCount: 0,\n      totalPauseDuration: 0\n    };\n    \n    this.completionPromise = new Promise((resolve, reject) => {\n      this.completionResolve = resolve;\n      this.completionReject = reject;\n    });\n  }\n  \n  async *tokens(): AsyncGenerator<TokenChunk> {\n    if (this.tokenGenerator) {\n      // Return existing generator if already created\n      yield* this.tokenGenerator;\n      return;\n    }\n    \n    // Create new token generator\n    this.tokenGenerator = this.createTokenGenerator();\n    yield* this.tokenGenerator;\n  }\n  \n  private async *createTokenGenerator(): AsyncGenerator<TokenChunk> {\n    try {\n      let currentTextBlock: string = '';\n      \n      for await (const message of this.messageGenerator) {\n        // Check if paused or aborted\n        await this.controller.checkPause();\n        if (this.controller.isAborted) {\n          throw new Error('Stream aborted');\n        }\n        \n        // Process assistant messages for text content\n        if (message.type === 'assistant') {\n          const assistantMessage = message as AssistantMessage;\n          \n          for (const block of assistantMessage.content) {\n            await this.controller.checkPause();\n            if (this.controller.isAborted) {\n              throw new Error('Stream aborted');\n            }\n            \n            if (block.type === 'text') {\n              const textBlock = block as TextBlock;\n              const text = textBlock.text;\n              \n              // Split into tokens (simple word-based tokenization for now)\n              // In production, this would use proper tokenization\n              const tokens = this.tokenizeText(text, currentTextBlock);\n              \n              for (const token of tokens) {\n                await this.controller.checkPause();\n                if (this.controller.isAborted) {\n                  throw new Error('Stream aborted');\n                }\n                \n                const chunk: TokenChunk = {\n                  token,\n                  timestamp: Date.now(),\n                  metadata: {\n                    messageId: `msg-${Date.now()}`,\n                    blockIndex: 0,\n                    position: this.metrics.tokensEmitted\n                  }\n                };\n                \n                this.snapshot.push(chunk);\n                this.metrics.tokensEmitted++;\n                this.metrics.bytesReceived = (this.metrics.bytesReceived || 0) + new TextEncoder().encode(token).length;\n                this.metrics.lastTokenTime = Date.now();\n                \n                // Update metrics\n                this.updateMetrics();\n                \n                // Emit token event\n                this.emit('token', chunk);\n                \n                yield chunk;\n              }\n              \n              currentTextBlock = text;\n            }\n          }\n        }\n      }\n      \n      this.metrics.state = 'completed';\n      this.updateMetrics();\n      this.emit('complete', this.metrics.state);\n      if (this.completionResolve) this.completionResolve();\n    } catch (error) {\n      this.metrics.state = 'error';\n      this.updateMetrics();\n      this.emit('error', error);\n      if (this.completionReject) this.completionReject(error as Error);\n      throw error;\n    }\n  }\n  \n  private tokenizeText(text: string, previousText: string): string[] {\n    // Simple token extraction that preserves word boundaries and punctuation\n    const tokens: string[] = [];\n    \n    // If we have previous text, find the difference\n    if (previousText && text.startsWith(previousText)) {\n      const newText = text.substring(previousText.length);\n      if (newText) {\n        // Split on word boundaries but keep delimiters\n        const parts = newText.split(/(\\s+|[.,!?;:])/);\n        for (const part of parts) {\n          if (part) {\n            tokens.push(part);\n          }\n        }\n      }\n    } else {\n      // Process entire text\n      const parts = text.split(/(\\s+|[.,!?;:])/);\n      for (const part of parts) {\n        if (part) {\n          tokens.push(part);\n        }\n      }\n    }\n    \n    return tokens;\n  }\n  \n  private updateMetrics(): void {\n    this.metrics.duration = Date.now() - this.startTime;\n    if (this.metrics.tokensEmitted > 0 && this.metrics.duration > 0) {\n      this.metrics.averageTokensPerSecond = this.metrics.tokensEmitted / (this.metrics.duration / 1000);\n    }\n    \n    // Update pause metrics from controller\n    this.metrics.pauseCount = this.controller.getPauseCount();\n    this.metrics.totalPauseDuration = this.controller.getTotalPauseDuration();\n  }\n  \n  getController(): StreamController {\n    return this.controller;\n  }\n  \n  getSnapshot(): TokenChunk[] {\n    return [...this.snapshot];\n  }\n  \n  getMetrics(): StreamMetrics {\n    this.updateMetrics();\n    return { ...this.metrics };\n  }\n  \n  async waitForCompletion(): Promise<void> {\n    return this.completionPromise;\n  }\n  \n  on(event: StreamEvent, handler: StreamEventHandler): void {\n    if (!this.eventHandlers.has(event)) {\n      this.eventHandlers.set(event, new Set());\n    }\n    this.eventHandlers.get(event)!.add(handler);\n  }\n  \n  off(event: StreamEvent, handler: StreamEventHandler): void {\n    this.eventHandlers.get(event)?.delete(handler);\n  }\n  \n  private emit(event: StreamEvent, data?: unknown): void {\n    const handlers = this.eventHandlers.get(event);\n    if (handlers) {\n      for (const handler of handlers) {\n        try {\n          handler(data as any);\n        } catch (error) {\n          // Error in ${event} handler - silently continue\n        }\n      }\n    }\n    \n    // Also emit metrics event on certain events\n    if (['token', 'pause', 'resume', 'complete', 'error'].includes(event)) {\n      this.emit('metrics', this.getMetrics());\n    }\n  }\n}\n\nclass StreamControllerImpl implements StreamController {\n  private state: StreamState = 'active';\n  private pausePromise?: Promise<void>;\n  private pauseResolve?: () => void;\n  private listeners: Map<string, Set<(...args: unknown[]) => void>> = new Map();\n  private pauseStartTime?: number;\n  private _abortReason?: string;\n  private pauseCount = 0;\n  private totalPauseDuration = 0;\n  \n  pause(): void {\n    if (this.state === 'active') {\n      this.state = 'paused';\n      this.pauseStartTime = Date.now();\n      this.pauseCount++;\n      this.pausePromise = new Promise(resolve => {\n        this.pauseResolve = resolve;\n      });\n      this.emit('pause');\n    }\n  }\n  \n  resume(): void {\n    if (this.state === 'paused' && this.pauseResolve) {\n      this.state = 'active';\n      this.pauseResolve();\n      this.pausePromise = undefined;\n      this.pauseResolve = undefined;\n      \n      if (this.pauseStartTime) {\n        const pauseDuration = Date.now() - this.pauseStartTime;\n        this.totalPauseDuration += pauseDuration;\n        this.pauseStartTime = undefined;\n        this.emit('resume', { pauseDuration });\n      } else {\n        this.emit('resume');\n      }\n    }\n  }\n  \n  abort(reason?: string): void {\n    this.state = 'aborted';\n    this._abortReason = reason;\n    if (this.pauseResolve) {\n      this.pauseResolve();\n    }\n    this.emit('abort');\n  }\n  \n  getState(): StreamState {\n    return this.state;\n  }\n  \n  get isPaused(): boolean {\n    return this.state === 'paused';\n  }\n  \n  get isAborted(): boolean {\n    return this.state === 'aborted';\n  }\n  \n  get abortReason(): string | undefined {\n    return this._abortReason;\n  }\n  \n  getPauseCount(): number {\n    return this.pauseCount;\n  }\n  \n  getTotalPauseDuration(): number {\n    // Add current pause duration if paused\n    if (this.state === 'paused' && this.pauseStartTime) {\n      return this.totalPauseDuration + (Date.now() - this.pauseStartTime);\n    }\n    return this.totalPauseDuration;\n  }\n  \n  async checkPause(): Promise<void> {\n    if (this.pausePromise) {\n      await this.pausePromise;\n    }\n  }\n  \n  on(event: 'pause' | 'resume' | 'abort', listener: () => void): void {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set());\n    }\n    this.listeners.get(event)!.add(listener);\n  }\n  \n  off(event: 'pause' | 'resume' | 'abort', listener: () => void): void {\n    this.listeners.get(event)?.delete(listener);\n  }\n  \n  private emit(event: string, _data?: unknown): void {\n    const listeners = this.listeners.get(event);\n    if (listeners) {\n      for (const listener of listeners) {\n        try {\n          listener();\n        } catch (error) {\n          // Error in ${event} listener - silently continue\n        }\n      }\n    }\n  }\n}\n\n// Export factory function\nexport function createTokenStream(messageGenerator: AsyncGenerator<Message>): TokenStream {\n  return new TokenStreamImpl(messageGenerator);\n}","/**\n * Per-call tool permission implementation\n */\n\nimport type {\n  ToolOverrides,\n  ToolPermission,\n  PermissionContext,\n  DynamicPermissionFunction,\n  PermissionResolution,\n} from '../types/per-call-permissions.js';\nimport type { ToolName, ClaudeCodeOptions } from '../types.js';\n\nexport class ToolPermissionManager {\n  private globalPermissions: Map<ToolName, ToolPermission>;\n  private rolePermissions: Map<ToolName, ToolPermission>;\n  private resolutionLog: PermissionResolution[] = [];\n  \n  constructor(\n    options: ClaudeCodeOptions,\n    rolePermissions?: Record<ToolName, ToolPermission>\n  ) {\n    // Initialize global permissions from options\n    this.globalPermissions = this.initializeGlobalPermissions(options);\n    \n    // Initialize role permissions if provided\n    this.rolePermissions = new Map(\n      rolePermissions ? Object.entries(rolePermissions) as [ToolName, ToolPermission][] : []\n    );\n  }\n  \n  private initializeGlobalPermissions(options: ClaudeCodeOptions): Map<ToolName, ToolPermission> {\n    const permissions = new Map<ToolName, ToolPermission>();\n    \n    // Set allowed tools\n    if (options.allowedTools) {\n      for (const tool of options.allowedTools) {\n        permissions.set(tool, 'allow');\n      }\n    }\n    \n    // Set denied tools (overrides allowed)\n    if (options.deniedTools) {\n      for (const tool of options.deniedTools) {\n        permissions.set(tool, 'deny');\n      }\n    }\n    \n    // Legacy tools array support\n    if (options.tools) {\n      for (const tool of options.tools) {\n        if (!permissions.has(tool)) {\n          permissions.set(tool, 'allow');\n        }\n      }\n    }\n    \n    return permissions;\n  }\n  \n  /**\n   * Resolve permissions for a specific tool with optional overrides\n   */\n  async resolvePermission(\n    tool: ToolName,\n    context: PermissionContext,\n    overrides?: ToolOverrides\n  ): Promise<PermissionResolution> {\n    const resolution: PermissionResolution = {\n      tool,\n      permission: 'allow', // Default to allow\n      source: 'default',\n      context,\n      timestamp: Date.now()\n    };\n    \n    // 1. Check query-level overrides (highest priority)\n    if (overrides) {\n      const overridePermission = await this.checkOverrides(tool, context, overrides);\n      if (overridePermission !== undefined) {\n        resolution.permission = overridePermission;\n        resolution.source = 'query';\n        resolution.override = overrides;\n        this.resolutionLog.push(resolution);\n        return resolution;\n      }\n    }\n    \n    // 2. Check dynamic permissions\n    if (overrides?.dynamicPermissions) {\n      const dynamicPermission = await this.checkDynamicPermissions(\n        tool,\n        context,\n        overrides.dynamicPermissions\n      );\n      if (dynamicPermission !== undefined) {\n        resolution.permission = dynamicPermission;\n        resolution.source = 'dynamic';\n        resolution.override = overrides;\n        this.resolutionLog.push(resolution);\n        return resolution;\n      }\n    }\n    \n    // 3. Check role permissions\n    if (this.rolePermissions.has(tool)) {\n      resolution.permission = this.rolePermissions.get(tool)!;\n      resolution.source = 'role';\n      this.resolutionLog.push(resolution);\n      return resolution;\n    }\n    \n    // 4. Check global permissions\n    if (this.globalPermissions.has(tool)) {\n      resolution.permission = this.globalPermissions.get(tool)!;\n      resolution.source = 'global';\n      this.resolutionLog.push(resolution);\n      return resolution;\n    }\n    \n    // 5. Default permission\n    this.resolutionLog.push(resolution);\n    return resolution;\n  }\n  \n  /**\n   * Check query-level overrides\n   */\n  private async checkOverrides(\n    tool: ToolName,\n    _context: PermissionContext,\n    overrides: ToolOverrides\n  ): Promise<ToolPermission | undefined> {\n    // Check explicit deny list (highest priority)\n    if (overrides.deny?.includes(tool)) {\n      return 'deny';\n    }\n    \n    // Check explicit allow list\n    if (overrides.allow?.includes(tool)) {\n      return 'allow';\n    }\n    \n    // Check permission map\n    if (overrides.permissions?.[tool]) {\n      return overrides.permissions[tool];\n    }\n    \n    return undefined;\n  }\n  \n  /**\n   * Check dynamic permissions\n   */\n  private async checkDynamicPermissions(\n    tool: ToolName,\n    context: PermissionContext,\n    dynamicPermissions: Record<ToolName, DynamicPermissionFunction>\n  ): Promise<ToolPermission | undefined> {\n    const dynamicFn = dynamicPermissions[tool];\n    if (dynamicFn) {\n      try {\n        return await dynamicFn(context);\n      } catch (error) {\n        // Log error and fall through to next permission level\n        // Error in dynamic permission function for ${tool} - falling through to next permission level\n      }\n    }\n    \n    return undefined;\n  }\n  \n  /**\n   * Get permission resolution history\n   */\n  getResolutionHistory(): PermissionResolution[] {\n    return [...this.resolutionLog];\n  }\n  \n  /**\n   * Clear resolution history\n   */\n  clearHistory(): void {\n    this.resolutionLog = [];\n  }\n  \n  /**\n   * Update role permissions\n   */\n  updateRolePermissions(permissions: Record<ToolName, ToolPermission>): void {\n    this.rolePermissions = new Map(Object.entries(permissions) as [ToolName, ToolPermission][]);\n  }\n  \n  /**\n   * Check if a tool is allowed with current configuration\n   */\n  async isToolAllowed(\n    tool: ToolName,\n    context: PermissionContext,\n    overrides?: ToolOverrides\n  ): Promise<boolean> {\n    const resolution = await this.resolvePermission(tool, context, overrides);\n    return resolution.permission === 'allow';\n  }\n  \n  /**\n   * Get effective permissions for a context\n   */\n  async getEffectivePermissions(\n    context: PermissionContext,\n    overrides?: ToolOverrides\n  ): Promise<Map<ToolName, PermissionResolution>> {\n    const allTools: ToolName[] = [\n      'Read', 'Write', 'Edit', 'Bash', 'Grep', 'Glob', 'LS',\n      'MultiEdit', 'NotebookRead', 'NotebookEdit', 'WebFetch',\n      'TodoRead', 'TodoWrite', 'WebSearch', 'Task', 'MCPTool'\n    ];\n    \n    const effectivePermissions = new Map<ToolName, PermissionResolution>();\n    \n    for (const tool of allTools) {\n      const resolution = await this.resolvePermission(tool, context, overrides);\n      effectivePermissions.set(tool, resolution);\n    }\n    \n    return effectivePermissions;\n  }\n}\n\n// Export factory function\nexport function createPermissionManager(\n  options: ClaudeCodeOptions,\n  rolePermissions?: Record<ToolName, ToolPermission>\n): ToolPermissionManager {\n  return new ToolPermissionManager(options, rolePermissions);\n}","/**\n * Simplified OpenTelemetry provider stub\n */\n\nimport type {\n  TelemetryProvider,\n  TelemetryLogger,\n  TelemetryConfig,\n  QueryMetrics,\n  ToolMetrics\n} from '../types/telemetry.js';\n\nexport class ClaudeTelemetryProvider implements TelemetryProvider {\n  async initialize(_config: TelemetryConfig): Promise<void> {\n    // Stub implementation\n  }\n  \n  getLogger(_name?: string): TelemetryLogger {\n    throw new Error('Telemetry provider not fully implemented yet');\n  }\n  \n  async shutdown(): Promise<void> {\n    // Stub implementation\n  }\n  \n  async forceFlush(): Promise<void> {\n    // Stub implementation\n  }\n  \n  getQueryMetrics(): QueryMetrics {\n    return {\n      totalQueries: 0,\n      successfulQueries: 0,\n      failedQueries: 0,\n      totalTokens: 0,\n      inputTokens: 0,\n      outputTokens: 0,\n      cacheHits: 0,\n      cacheMisses: 0,\n      averageQueryDuration: 0,\n      p95QueryDuration: 0,\n      p99QueryDuration: 0\n    };\n  }\n  \n  getToolMetrics(): Map<string, ToolMetrics> {\n    return new Map();\n  }\n}\n\nexport function createTelemetryProvider(): TelemetryProvider {\n  return new ClaudeTelemetryProvider();\n}\n\n// Stub for TelemetryUtils\nexport class TelemetryUtils {\n  static extractTraceContext(_headers: Record<string, string>): unknown {\n    return {};\n  }\n  \n  static injectTraceContext(_context: unknown, _headers: Record<string, string>): void {\n    // Stub\n  }\n  \n  static createNoOpProvider(): TelemetryProvider {\n    return new ClaudeTelemetryProvider();\n  }\n}","/**\n * Retry executor implementation with exponential backoff\n */\n\nimport type {\n  RetryExecutor,\n  RetryOptions,\n  RetryResult,\n  RetryExecutorStats,\n  RetryStrategy\n} from '../types/retry.js';\nimport {\n  ExponentialBackoffStrategy,\n  LinearBackoffStrategy,\n  FibonacciBackoffStrategy,\n  RetryUtils\n} from '../types/retry.js';\n\nexport class ClaudeRetryExecutor implements RetryExecutor {\n  private defaults: RetryOptions = {\n    maxAttempts: 3,\n    initialDelay: 1000,\n    maxDelay: 30000,\n    multiplier: 2,\n    jitter: true,\n    jitterFactor: 0.1\n  };\n  \n  private stats: RetryExecutorStats = {\n    totalExecutions: 0,\n    successfulFirstAttempts: 0,\n    successfulRetries: 0,\n    totalFailures: 0,\n    totalRetryAttempts: 0,\n    averageAttempts: 0,\n    maxAttempts: 0\n  };\n  \n  private strategy: RetryStrategy;\n  \n  constructor(options?: RetryOptions, strategy?: RetryStrategy) {\n    if (options) {\n      this.defaults = { ...this.defaults, ...options };\n    }\n    \n    this.strategy = strategy || new ExponentialBackoffStrategy({\n      multiplier: this.defaults.multiplier,\n      maxDelay: this.defaults.maxDelay,\n      jitter: this.defaults.jitter,\n      jitterFactor: this.defaults.jitterFactor\n    });\n  }\n  \n  async execute<T>(fn: () => Promise<T>, options?: RetryOptions): Promise<T> {\n    const result = await this.executeWithResult(fn, options);\n    return result.value;\n  }\n  \n  async executeWithResult<T>(\n    fn: () => Promise<T>,\n    options?: RetryOptions\n  ): Promise<RetryResult<T>> {\n    const opts = { ...this.defaults, ...options };\n    const errors: Error[] = [];\n    const startTime = Date.now();\n    \n    // Update stats\n    this.stats.totalExecutions++;\n    \n    // Check for abort signal\n    if (opts.signal?.aborted) {\n      throw new Error('Operation aborted before execution');\n    }\n    \n    // Set up total timeout if specified\n    let totalTimeoutId: NodeJS.Timeout | undefined;\n    let totalTimeoutPromise: Promise<never> | undefined;\n    \n    if (opts.totalTimeout) {\n      totalTimeoutPromise = new Promise((_, reject) => {\n        totalTimeoutId = setTimeout(() => {\n          reject(new Error(`Total timeout of ${opts.totalTimeout}ms exceeded`));\n        }, opts.totalTimeout);\n      });\n    }\n    \n    try {\n      for (let attempt = 1; attempt <= (opts.maxAttempts || 3); attempt++) {\n        try {\n          // Check abort signal\n          if (opts.signal?.aborted) {\n            throw new Error('Operation aborted');\n          }\n          \n          // Create attempt with timeout\n          let attemptPromise = fn();\n          \n          if (opts.attemptTimeout) {\n            const timeoutPromise = new Promise<never>((_, reject) => {\n              setTimeout(() => {\n                reject(new Error(`Attempt timeout of ${opts.attemptTimeout}ms exceeded`));\n              }, opts.attemptTimeout);\n            });\n            \n            attemptPromise = Promise.race([attemptPromise, timeoutPromise]);\n          }\n          \n          // Race against total timeout if set\n          const value = await (totalTimeoutPromise \n            ? Promise.race([attemptPromise, totalTimeoutPromise])\n            : attemptPromise);\n          \n          // Success!\n          if (attempt === 1) {\n            this.stats.successfulFirstAttempts++;\n          } else {\n            this.stats.successfulRetries++;\n          }\n          \n          this.updateStats(attempt);\n          \n          return {\n            value,\n            attempts: attempt,\n            totalDuration: Date.now() - startTime,\n            errors\n          };\n          \n        } catch (error) {\n          errors.push(error as Error);\n          \n          // Check if should retry\n          const shouldRetry = await this.shouldRetry(error as Error, attempt, opts);\n          \n          if (!shouldRetry || attempt === opts.maxAttempts) {\n            this.stats.totalFailures++;\n            this.updateStats(attempt);\n            throw error;\n          }\n          \n          // Calculate delay\n          const delay = this.strategy.calculateDelay(attempt, opts.initialDelay || 1000);\n          \n          // Call retry callback\n          if (opts.onRetry) {\n            await opts.onRetry(attempt, error as Error, delay);\n          }\n          \n          // Wait before retry\n          await this.sleep(delay, opts.signal);\n          this.stats.totalRetryAttempts++;\n        }\n      }\n      \n      // Should never reach here\n      throw errors[errors.length - 1];\n      \n    } finally {\n      if (totalTimeoutId) {\n        clearTimeout(totalTimeoutId);\n      }\n    }\n  }\n  \n  setDefaults(options: RetryOptions): void {\n    this.defaults = { ...this.defaults, ...options };\n    \n    // Update strategy if needed\n    if (options.multiplier || options.maxDelay || options.jitter || options.jitterFactor) {\n      this.strategy = new ExponentialBackoffStrategy({\n        multiplier: options.multiplier || this.defaults.multiplier,\n        maxDelay: options.maxDelay || this.defaults.maxDelay,\n        jitter: options.jitter ?? this.defaults.jitter,\n        jitterFactor: options.jitterFactor || this.defaults.jitterFactor\n      });\n    }\n  }\n  \n  getStats(): RetryExecutorStats {\n    return { ...this.stats };\n  }\n  \n  resetStats(): void {\n    this.stats = {\n      totalExecutions: 0,\n      successfulFirstAttempts: 0,\n      successfulRetries: 0,\n      totalFailures: 0,\n      totalRetryAttempts: 0,\n      averageAttempts: 0,\n      maxAttempts: 0\n    };\n  }\n  \n  private async shouldRetry(error: Error, attempt: number, options: RetryOptions): Promise<boolean> {\n    // Check custom retry predicate\n    if (options.shouldRetry) {\n      return options.shouldRetry(error, attempt);\n    }\n    \n    // Check strategy\n    if (!this.strategy.shouldRetry(error, attempt)) {\n      return false;\n    }\n    \n    // Check retryable error types\n    if (options.retryableErrors) {\n      return options.retryableErrors.some(ErrorClass => error instanceof ErrorClass);\n    }\n    \n    // Default to RetryUtils check\n    return RetryUtils.isRetryableError(error);\n  }\n  \n  private async sleep(ms: number, signal?: AbortSignal): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        cleanup();\n        resolve();\n      }, ms);\n      \n      const cleanup = () => {\n        clearTimeout(timeoutId);\n        signal?.removeEventListener('abort', onAbort);\n      };\n      \n      const onAbort = () => {\n        cleanup();\n        reject(new Error('Sleep aborted'));\n      };\n      \n      if (signal?.aborted) {\n        reject(new Error('Sleep aborted'));\n        return;\n      }\n      \n      signal?.addEventListener('abort', onAbort);\n    });\n  }\n  \n  private updateStats(attempts: number): void {\n    this.stats.maxAttempts = Math.max(this.stats.maxAttempts, attempts);\n    \n    const totalAttempts = \n      this.stats.successfulFirstAttempts +\n      (this.stats.successfulRetries * 2) + // At least 2 attempts for retries\n      (this.stats.totalFailures * (this.defaults.maxAttempts || 3));\n    \n    this.stats.averageAttempts = totalAttempts / this.stats.totalExecutions;\n  }\n}\n\n// Factory functions for creating retry executors with different strategies\nexport function createRetryExecutor(options?: RetryOptions): RetryExecutor {\n  return new ClaudeRetryExecutor(options);\n}\n\nexport function createExponentialRetryExecutor(options?: RetryOptions): RetryExecutor {\n  return new ClaudeRetryExecutor(options, new ExponentialBackoffStrategy({\n    multiplier: options?.multiplier,\n    maxDelay: options?.maxDelay,\n    jitter: options?.jitter,\n    jitterFactor: options?.jitterFactor\n  }));\n}\n\nexport function createLinearRetryExecutor(options?: RetryOptions & { increment?: number }): RetryExecutor {\n  return new ClaudeRetryExecutor(options, new LinearBackoffStrategy({\n    increment: options?.increment,\n    maxDelay: options?.maxDelay,\n    jitter: options?.jitter\n  }));\n}\n\nexport function createFibonacciRetryExecutor(options?: RetryOptions): RetryExecutor {\n  return new ClaudeRetryExecutor(options, new FibonacciBackoffStrategy({\n    maxDelay: options?.maxDelay,\n    jitter: options?.jitter\n  }));\n}\n\n// Convenience function for wrapping any async function with retry\nexport function withRetry<T>(\n  fn: () => Promise<T>,\n  options?: RetryOptions\n): () => Promise<T> {\n  const executor = createRetryExecutor(options);\n  return () => executor.execute(fn);\n}","import { InternalClient } from './_internal/client.js';\nimport type { ClaudeCodeOptions, Message } from './types.js';\n\n/**\n * Query Claude Code with a prompt and options.\n * \n * @param prompt - The prompt to send to Claude Code\n * @param options - Configuration options for the query\n * @returns An async iterator that yields messages from Claude Code\n * \n * @example\n * ```typescript\n * import { query } from '@instantlyeasy/claude-code-sdk-ts';\n * \n * for await (const message of query('Create a hello.txt file')) {\n *   console.log(message);\n * }\n * ```\n * \n * @example\n * ```typescript\n * import { query, ClaudeCodeOptions } from '@instantlyeasy/claude-code-sdk-ts';\n * \n * const options: ClaudeCodeOptions = {\n *   allowedTools: ['Read', 'Write'],\n *   permissionMode: 'acceptEdits',\n *   cwd: '/Users/me/projects'\n * };\n * \n * for await (const message of query('Analyze this codebase', options)) {\n *   if (message.type === 'assistant') {\n *     // Handle assistant messages\n *   } else if (message.type === 'result') {\n *     // Handle final result\n *   }\n * }\n * ```\n */\nexport async function* query(\n  prompt: string,\n  options?: ClaudeCodeOptions\n): AsyncGenerator<Message> {\n  const client = new InternalClient(prompt, options);\n  yield* client.processQuery();\n}\n\n// Re-export all types\nexport * from './types.js';\nexport * from './errors.js';\nexport { AbortError } from './errors.js';\n\n// Export enhanced error utilities\nexport { \n  isEnhancedError, \n  hasResolution \n} from './types/environment.js';\nexport { API_KEY_SAFETY_WARNING } from './environment.js';\n\n// Export new fluent API (backward compatible - original query function still available)\nexport { claude, QueryBuilder } from './fluent.js';\nexport { ResponseParser, type ToolExecution, type UsageStats } from './parser.js';\nexport { \n  Logger, \n  LogLevel, \n  ConsoleLogger, \n  JSONLogger, \n  MultiLogger, \n  NullLogger,\n  type LogEntry \n} from './logger.js';\n\n// Export enhanced features (functions and classes only, types come from types.js)\nexport {\n  // Error handling\n  detectErrorType,\n  createTypedError,\n  // Token streaming\n  createTokenStream,\n  TokenStreamImpl,\n  // Per-call permissions\n  createPermissionManager,\n  ToolPermissionManager,\n  // Telemetry\n  createTelemetryProvider,\n  ClaudeTelemetryProvider,\n  TelemetryUtils,\n  // Retry and backoff\n  createRetryExecutor,\n  createExponentialRetryExecutor,\n  createLinearRetryExecutor,\n  createFibonacciRetryExecutor,\n  withRetry,\n  ClaudeRetryExecutor\n} from './enhanced/index.js';"],"mappings":"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","names":["process","path","fs","path","path","fs","LogLevel","ToolPermissionManager"]}